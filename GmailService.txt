// ====================================================================
// GMAIL SERVICE - Gestione operazioni Gmail
// âœ… Supporto header Reply-To
// âœ… Label cache per evitare chiamate ripetute
// âœ… Costruttore cronologia conversazione
// ====================================================================

/**
 * GmailService - Servizio gestione Gmail
 * 
 * FUNZIONALITÃ€ PRINCIPALI:
 * âœ… Label cache per performance
 * âœ… Supporto header Reply-To per form web
 * âœ… Costruttore cronologia conversazione
 * âœ… Rimozione citazioni/firme
 */
class GmailService {
  constructor() {
    console.log('ðŸ“§ Inizializzazione GmailService...');
    
    // Cache etichette per evitare chiamate API ripetute con TTL
    this._labelCache = new Map(); // Map<labelName, {label: GmailLabel, ts: number}>
    this._cacheTTL = 60 * 60 * 1000; // 1 hour TTL for cached labels

    console.log('âœ“ GmailService inizializzato con cache etichette (TTL 1h)');
  }
  
  // ========================================================================
  // LABEL MANAGEMENT (with cache)
  // ========================================================================
  
  /**
   * Ottiene o crea un'etichetta Gmail con caching
   */
  getOrCreateLabel(labelName) {
    // Check cache first with TTL validation
    const cachedEntry = this._labelCache.get(labelName);
    const now = Date.now();
    if (cachedEntry && (now - cachedEntry.ts) < this._cacheTTL) {
      console.log(`ðŸ“¦ Label '${labelName}' found in cache`);
      return cachedEntry.label;
    } else if (cachedEntry) {
      // Stale entry, remove
      this._labelCache.delete(labelName);
    }

    // Check if label exists in Gmail
    const labels = GmailApp.getUserLabels();
    for (const label of labels) {
      if (label.getName() === labelName) {
        // Cache with timestamp and return
        this._labelCache.set(labelName, { label: label, ts: now });
        console.log(`âœ“ Label '${labelName}' found`);
        return label;
      }
    }

    // Create new label
    const newLabel = GmailApp.createLabel(labelName);
    this._labelCache.set(labelName, { label: newLabel, ts: now });
    console.log(`âœ“ Created new label: ${labelName}`);
    return newLabel;
  }
  
  /**
   * Clear the label cache
   */
  clearLabelCache() {
    this._labelCache.clear();
    console.log('ðŸ—‘ï¸ Label cache cleared');
  }
  
  /**
   * Add label to thread
   */
  addLabelToThread(thread, labelName) {
    const label = this.getOrCreateLabel(labelName);
    thread.addLabel(label);
    console.log(`âœ“ Added label '${labelName}' to thread`);
  }
  
  // ========================================================================
  // MESSAGE EXTRACTION (with Reply-To support)
  // ========================================================================
  
  /**
   * Estrae dettagli messaggio con supporto Reply-To
   */
  extractMessageDetails(message) {
    const subject = message.getSubject();
    const sender = message.getFrom();
    const date = message.getDate();
    const body = message.getPlainBody() || this._htmlToPlainText(message.getBody());
    const messageId = message.getId();
    
    // Ottieni header Reply-To
    const replyTo = message.getReplyTo();
    
    // Use Reply-To if present and valid
    let effectiveSender;
    let hasReplyTo = false;
    
    if (replyTo && replyTo.includes('@') && replyTo !== sender) {
      effectiveSender = replyTo;
      hasReplyTo = true;
      console.log(`   ðŸ“§ Using Reply-To: ${replyTo} (Original From: ${sender})`);
    } else {
      effectiveSender = sender;
    }
    
    // Extract name and email
    const senderName = this._extractSenderName(effectiveSender);
    const senderEmail = this._extractEmailAddress(effectiveSender);
    
    return {
      id: messageId,
      subject: subject,
      sender: effectiveSender,
      senderName: senderName,
      senderEmail: senderEmail,
      date: date,
      body: body,
      originalFrom: sender,
      hasReplyTo: hasReplyTo
    };
  }
  
  /**
   * Extract sender name from From field
   */
  _extractSenderName(fromField) {
    const match = fromField.match(/^"?(.+?)"?\s*</);
    if (match) {
      return match[1].trim();
    }
    
    // Use email prefix as fallback
    const email = this._extractEmailAddress(fromField);
    if (email) {
      return email.split('@')[0];
    }
    
    return 'Utente';
  }
  
  /**
   * Extract email address from From field
   */
  _extractEmailAddress(fromField) {
    const match = fromField.match(/<(.+?)>/);
    if (match) {
      return match[1];
    }
    
    // If no brackets, check if whole field is email
    if (fromField.includes('@')) {
      return fromField.trim();
    }
    
    return '';
  }
  
  /**
   * Convert HTML to plain text
   */
  _htmlToPlainText(html) {
    if (!html) return '';
    
    // Remove HTML tags
    let text = html.replace(/<[^>]+>/g, ' ');
    // Decode HTML entities
    text = text.replace(/&nbsp;/g, ' ')
               .replace(/&amp;/g, '&')
               .replace(/&lt;/g, '<')
               .replace(/&gt;/g, '>');
    // Clean up whitespace
    text = text.replace(/\s+/g, ' ').trim();
    
    return text;
  }
  
  // ========================================================================
  // CONVERSATION HISTORY
  // ========================================================================
  
  /**
   * Costruisce cronologia conversazione da messaggi thread
   */
  buildConversationHistory(messages, maxMessages = 10, ourEmail = '') {
    // Fallback: get our email if not provided
    if (!ourEmail) {
      ourEmail = Session.getActiveUser().getEmail();
    }
    
    // Limit number of messages
    if (messages.length > maxMessages) {
      console.warn(`âš ï¸ Thread with ${messages.length} messages, limiting to last ${maxMessages}`);
      messages = messages.slice(-maxMessages);
    }
    
    const history = [];
    
    for (const msg of messages) {
      const details = this.extractMessageDetails(msg);
      const isOurs = ourEmail && details.senderEmail.toLowerCase() === ourEmail.toLowerCase();
      
      const prefix = isOurs ? 'Segreteria' : `Utente (${details.senderName})`;
      
      // Truncate very long messages
      let body = details.body;
      if (body.length > 2000) {
        body = body.substring(0, 2000) + '\n[... messaggio troncato ...]';
      }
      
      history.push(`${prefix}: ${body}\n---`);
    }
    
    return history.join('\n');
  }
  
  // ========================================================================
  // QUOTE/SIGNATURE REMOVAL
  // ========================================================================
  
  /**
   * Estrae contenuto principale risposta, rimuovendo testo citato
   */
  extractMainReply(content) {
    const markers = [
      /^>/m,
      /^On .* wrote:/m,
      /^Il giorno .* ha scritto:/m,
      /^-{3,}.*Original Message/m
    ];
    
    let result = content;
    
    for (const marker of markers) {
      const match = content.search(marker);
      if (match !== -1) {
        result = content.substring(0, match);
        break;
      }
    }
    
    // Remove signatures
    const sigMarkers = [
      /cordiali saluti/i,
      /distinti saluti/i,
      /in fede/i,
      /best regards/i,
      /sincerely/i,
      /sent from my iphone/i,
      /inviato da/i
    ];
    
    for (const marker of sigMarkers) {
      const match = result.search(marker);
      if (match !== -1) {
        result = result.substring(0, match);
        break;
      }
    }
    
    return result.trim();
  }
  
  // ========================================================================
  // SEND REPLY
  // ========================================================================
  
  /**
   * Send reply to a thread
   * âœ… Uses sender_email which includes Reply-To when present
   */
  sendReply(thread, replyText, messageDetails) {
    // Get the GmailThread object if it's an ID
    const gmailThread = typeof thread === 'string' ? 
                        GmailApp.getThreadById(thread) : thread;
    
    // Reply to thread (Gmail handles threading automatically)
    gmailThread.reply(replyText);
    
    console.log(`âœ“ Reply sent to ${messageDetails.senderEmail}`);
    
    if (messageDetails.hasReplyTo) {
      console.log('   ðŸ“§ Reply sent to Reply-To address');
    }
    
    return true;
  }
  
  /**
   * Send reply as HTML (for formatted responses)
   * âœ… Applies formatting safeguards (legacy feature)
   * âœ… Applies custom replacements from Sostituzioni sheet
   */
  sendHtmlReply(thread, responseText, messageDetails) {
    // 0. Apply Custom Replacements (from Sostituzioni sheet)
    let finalResponse = responseText;
    if (typeof GLOBAL_CACHE !== 'undefined' && GLOBAL_CACHE.replacements) {
      const replacementCount = Object.keys(GLOBAL_CACHE.replacements).length;
      if (replacementCount > 0) {
        finalResponse = this.applyReplacements(finalResponse, GLOBAL_CACHE.replacements);
        console.log(`   âœ“ Applied ${replacementCount} replacement rules`);
      }
    }
    
    // 1. Apply Formatting Safeguards (Legacy restoration)
    finalResponse = this.fixPunctuation(finalResponse);
    finalResponse = this.ensureGreetingLineBreak(finalResponse);

    // 2. Convert to HTML
    const htmlBody = markdownToHtml(finalResponse);

    const gmailThread = typeof thread === 'string'
      ? GmailApp.getThreadById(thread)
      : thread;

    gmailThread.reply('', {
      htmlBody: htmlBody
    });

    console.log(`âœ“ HTML reply sent to ${messageDetails.senderEmail}`);
  }

  // ========================================================================
  // FORMATTING SAFEGUARDS (Legacy Features)
  // ========================================================================

  /**
   * Corregge errori comuni di punteggiatura
   * Es. "Buongiorno, Siamo" -> "Buongiorno, siamo"
   * 
   * COMPORTAMENTO INTENZIONALE:
   * - Corregge SOLO parole con prima lettera maiuscola + resto minuscolo (es. "Siamo")
   * - NON modifica acronimi/sigle tutto maiuscolo (es. "DON", "SPQR", "CEI")
   *   perchÃ© la regex cattura solo [A-Z][a-z]*, non [A-Z]+
   * - Eccezioni esplicite per titoli: Don, Padre, Suor, Monsignor, Papa, Signore, Signora
   */
  fixPunctuation(text) {
    if (!text) return text;
    
    // Parole che DEVONO rimanere maiuscole dopo virgola (titoli, nomi propri)
    const exceptions = ['Don', 'Padre', 'Suor', 'Monsignor', 'Papa', 'Signore', 'Signora'];
    
    // Fix generico: minuscola dopo virgola (escluse eccezioni e acronimi tutto-maiuscolo)
    return text.replace(/,\s+([A-ZÃ€ÃˆÃ‰ÃŒÃ’Ã™])([a-zÃ Ã¨Ã©Ã¬Ã²Ã¹]*)/g, (match, firstLetter, rest) => {
      const word = firstLetter + rest;
      // Mantieni se Ã¨ un'eccezione
      if (exceptions.includes(word)) {
        return match;
      }
      return `, ${firstLetter.toLowerCase()}${rest}`;
    });
  }

  /**
   * Ensures there is a blank line after the greeting
   */
  ensureGreetingLineBreak(text) {
    if (!text) return text;

    // Pattern: Greeting line (start of string, some words, maybe comma/exclamation, newline)
    // Followed by immediate text without empty line.
    
    // E.g. ^Buongiorno, \nSiamo... -> ^Buongiorno, \n\nSiamo...
    
    const lines = text.split('\n');
    if (lines.length > 1) {
      const firstLine = lines[0].trim();
      // Check if it looks like a greeting
      if (/^(Buongiorno|Buonasera|Salve|Gentile|Egregio|Ciao)/i.test(firstLine)) {
        // Check if second line is NOT empty
        if (lines[1].trim() !== '') {
            // Insert empty line
            lines.splice(1, 0, '');
            return lines.join('\n');
        }
      }
    }
    return text;
  }

  /**
   * Applies custom text replacements from the Sostituzioni sheet
   * @param {string} text - Text to apply replacements to
   * @param {Object} replacements - Map of {badText: goodText}
   */
  applyReplacements(text, replacements) {
    if (!text || !replacements) return text;
    
    let result = text;
    for (const [bad, good] of Object.entries(replacements)) {
      // Case insensitive global replace
      const regex = new RegExp(bad.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
      result = result.replace(regex, good);
    }
    return result;
  }

  // ========================================================================
  // HEALTH CHECK
  // ========================================================================
  
  /**
   * Test Gmail access
   */
  testConnection() {
    const results = {
      connectionOk: false,
      canListMessages: false,
      canCreateLabels: false,
      errors: []
    };
    
    try {
      // Test listing threads
      const threads = GmailApp.search('is:unread', 0, 1);
      results.connectionOk = true;
      results.canListMessages = true;
      
      // Test label creation
      try {
        const testLabel = this.getOrCreateLabel('_TEST_LABEL_');
        results.canCreateLabels = true;
        
        // Cleanup
        try {
          testLabel.deleteLabel();
        } catch (e) {
          // Non-critical
        }
      } catch (e) {
        results.errors.push(`Cannot create labels: ${e.message}`);
      }
      
    } catch (e) {
      results.errors.push(`Connection error: ${e.message}`);
    }
    
    results.isHealthy = results.connectionOk && results.canListMessages;
    return results;
  }
}

// Factory function
function createGmailService() {
  return new GmailService();
}

// ====================================================================
// MARKDOWN â†’ HTML (GLOBAL, REQUIRED BY GmailService)
// Ripristina stile originale: viola + font 20px
// ====================================================================

function markdownToHtml(text) {
  if (!text) return '';

  // âœ… FIX: Sanitize HTML to prevent injection attacks
  let html = text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');

  // Proteggi eventuali code blocks
  const codeBlocks = [];
  html = html.replace(/```[\s\S]*?```/g, (match) => {
    codeBlocks.push(match);
    return `__CODEBLOCK_${codeBlocks.length - 1}__`;
  });

  // Headers
  html = html.replace(/^###\s+(.+)$/gm, '<p style="font-size:16px;font-weight:bold;">$1</p>');
  html = html.replace(/^##\s+(.+)$/gm, '<p style="font-size:18px;font-weight:bold;">$1</p>');
  html = html.replace(/^#\s+(.+)$/gm, '<p style="font-size:20px;font-weight:bold;">$1</p>');

  // Bold / Italic
  html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  html = html.replace(/(?<!\*)\*(?!\*)(.+?)\*(?!\*)/g, '<em>$1</em>');

  // Links
  html = html.replace(/\[(.+?)\]\((.+?)\)/g, '<a href="$2" style="color:#351c75;">$1</a>');

  // Restore code blocks
  codeBlocks.forEach((block, i) => {
    const code = block.replace(/```/g, '').trim();
    html = html.replace(
      `__CODEBLOCK_${i}__`,
      `<pre style="background:#f4f4f4;padding:10px;border-radius:4px;font-family:monospace;">${code}</pre>`
    );
  });

  // Paragraphs and line breaks
  html = html.replace(/\n\n+/g, '</p><p>');
  html = html.replace(/\n/g, '<br>');

  // Convert emojis to HTML entities for better email compatibility
  // Convert all non-ASCII characters (emojis, accents, etc.) to HTML entities
  html = html.replace(/[^\x00-\x7F]/g, char => {
    return '&#' + char.codePointAt(0) + ';';
  });

  // Final wrapper (IDENTITÃ€ VISIVA ORIGINALE)
  return `
    <div style="
      font-family: Arial, Helvetica, sans-serif;
      font-size: 20px;
      color: #351c75;
      line-height: 1.6;
    ">
      <p>${html}</p>
    </div>
  `;
}
