// ====================================================================
// GMAIL SERVICE - Gestione operazioni Gmail
// âœ… Supporto header Reply-To
// âœ… Label cache per evitare chiamate ripetute
// âœ… Costruttore cronologia conversazione
// ====================================================================

/**
 * GmailService - Servizio gestione Gmail
 * 
 * FUNZIONALITÃ€ PRINCIPALI:
 * âœ… Label cache per performance
 * âœ… Supporto header Reply-To per form web
 * âœ… Costruttore cronologia conversazione
 * âœ… Rimozione citazioni/firme
 */
class GmailService {
  constructor() {
    console.log('ðŸ“§ Inizializzazione GmailService...');
    
    // Cache etichette per evitare chiamate API ripetute con TTL
    this._labelCache = new Map(); // Map<labelName, {label: GmailLabel, ts: number}>
    this._cacheTTL = 60 * 60 * 1000; // TTL 1 ora per etichette in cache

    console.log('âœ“ GmailService inizializzato con cache etichette (TTL 1h)');
  }
  
  // ========================================================================
  // GESTIONE ETICHETTE (con cache)
  // ========================================================================
  
  /**
   * Ottiene o crea un'etichetta Gmail con caching
   */
  getOrCreateLabel(labelName) {
    // Verifica prima la cache con validazione TTL
    const cachedEntry = this._labelCache.get(labelName);
    const now = Date.now();
    if (cachedEntry && (now - cachedEntry.ts) < this._cacheTTL) {
      console.log(`ðŸ“¦ Label '${labelName}' found in cache`);
      return cachedEntry.label;
    } else if (cachedEntry) {
      // Voce scaduta, rimuovi
      this._labelCache.delete(labelName);
    }

    // Verifica se l'etichetta esiste in Gmail
    const labels = GmailApp.getUserLabels();
    for (const label of labels) {
      if (label.getName() === labelName) {
        // Memorizza in cache con timestamp e ritorna
        this._labelCache.set(labelName, { label: label, ts: now });
        console.log(`âœ“ Label '${labelName}' found`);
        return label;
      }
    }

    // Crea nuova etichetta
    const newLabel = GmailApp.createLabel(labelName);
    this._labelCache.set(labelName, { label: newLabel, ts: now });
    console.log(`âœ“ Created new label: ${labelName}`);
    return newLabel;
  }
  
  /**
   * Svuota la cache delle etichette
   */
  clearLabelCache() {
    this._labelCache.clear();
    console.log('ðŸ—‘ï¸ Label cache cleared');
  }
  
  /**
   * Aggiunge etichetta a un thread
   */
  addLabelToThread(thread, labelName) {
    const label = this.getOrCreateLabel(labelName);
    thread.addLabel(label);
    console.log(`âœ“ Added label '${labelName}' to thread`);
  }
  
  // ========================================================================
  // ESTRAZIONE MESSAGGI (con supporto Reply-To)
  // ========================================================================
  
  /**
   * Estrae dettagli messaggio con supporto Reply-To
   */
  extractMessageDetails(message) {
    const subject = message.getSubject();
    const sender = message.getFrom();
    const date = message.getDate();
    const body = message.getPlainBody() || this._htmlToPlainText(message.getBody());
    const messageId = message.getId();
    
    // Ottieni header Reply-To
    const replyTo = message.getReplyTo();
    
    // Usa Reply-To se presente e valido
    let effectiveSender;
    let hasReplyTo = false;
    
    if (replyTo && replyTo.includes('@') && replyTo !== sender) {
      effectiveSender = replyTo;
      hasReplyTo = true;
      console.log(`   ðŸ“§ Using Reply-To: ${replyTo} (Original From: ${sender})`);
    } else {
      effectiveSender = sender;
    }
    
    // Estrai nome ed email
    const senderName = this._extractSenderName(effectiveSender);
    const senderEmail = this._extractEmailAddress(effectiveSender);
    
    return {
      id: messageId,
      subject: subject,
      sender: effectiveSender,
      senderName: senderName,
      senderEmail: senderEmail,
      date: date,
      body: body,
      originalFrom: sender,
      hasReplyTo: hasReplyTo
    };
  }
  
  /**
   * Estrae il nome del mittente dal campo From
   */
  _extractSenderName(fromField) {
    const match = fromField.match(/^"?(.+?)"?\s*</);
    let name = null;
    
    if (match) {
      name = match[1].trim();
    } else {
      // Usa prefisso email come fallback
      const email = this._extractEmailAddress(fromField);
      if (email) {
        name = email.split('@')[0];
      }
    }
    
    // Capitalizza il nome (prima lettera maiuscola per ogni parola)
    if (name) {
      return this._capitalizeName(name);
    }
    
    return 'Utente';
  }
  
  /**
   * Capitalizza un nome proprio (prima lettera maiuscola per ogni parola)
   */
  _capitalizeName(name) {
    if (!name) return name;
    
    return name
      .split(/[\s-]+/)
      .map(word => {
        if (word.length === 0) return word;
        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
      })
      .join(' ');
  }
  
  /**
   * Estrae indirizzo email dal campo From
   */
  _extractEmailAddress(fromField) {
    const match = fromField.match(/<(.+?)>/);
    if (match) {
      return match[1];
    }
    
    // Se non ci sono parentesi angolari, verifica se l'intero campo Ã¨ un email
    if (fromField.includes('@')) {
      return fromField.trim();
    }
    
    return '';
  }
  
  /**
   * Converte HTML in testo semplice
   */
  _htmlToPlainText(html) {
    if (!html) return '';
    
    // Rimuovi tag HTML
    let text = html.replace(/<[^>]+>/g, ' ');
    // Decodifica entitÃ  HTML
    text = text.replace(/&nbsp;/g, ' ')
               .replace(/&amp;/g, '&')
               .replace(/&lt;/g, '<')
               .replace(/&gt;/g, '>');
    // Pulisci spazi bianchi
    text = text.replace(/\s+/g, ' ').trim();
    
    return text;
  }
  
  // ========================================================================
  // CRONOLOGIA CONVERSAZIONE
  // ========================================================================
  
  /**
   * Costruisce cronologia conversazione da messaggi thread
   */
  buildConversationHistory(messages, maxMessages = 10, ourEmail = '') {
    // Fallback: ottieni nostra email se non fornita
    if (!ourEmail) {
      ourEmail = Session.getActiveUser().getEmail();
    }
    
    // Limita numero di messaggi
    if (messages.length > maxMessages) {
      console.warn(`âš ï¸ Thread with ${messages.length} messages, limiting to last ${maxMessages}`);
      messages = messages.slice(-maxMessages);
    }
    
    const history = [];
    
    for (const msg of messages) {
      const details = this.extractMessageDetails(msg);
      const isOurs = ourEmail && details.senderEmail.toLowerCase() === ourEmail.toLowerCase();
      
      const prefix = isOurs ? 'Segreteria' : `Utente (${details.senderName})`;
      
      // Tronca messaggi molto lunghi
      let body = details.body;
      if (body.length > 2000) {
        body = body.substring(0, 2000) + '\n[... messaggio troncato ...]';
      }
      
      history.push(`${prefix}: ${body}\n---`);
    }
    
    return history.join('\n');
  }
  
  // ========================================================================
  // RIMOZIONE CITAZIONI/FIRME
  // ========================================================================
  
  /**
   * Estrae contenuto principale risposta, rimuovendo testo citato
   */
  extractMainReply(content) {
    const markers = [
      /^>/m,
      /^On .* wrote:/m,
      /^Il giorno .* ha scritto:/m,
      /^-{3,}.*Original Message/m
    ];
    
    let result = content;
    
    for (const marker of markers) {
      const match = content.search(marker);
      if (match !== -1) {
        result = content.substring(0, match);
        break;
      }
    }
    
    // Rimuovi firme
    const sigMarkers = [
      /cordiali saluti/i,
      /distinti saluti/i,
      /in fede/i,
      /best regards/i,
      /sincerely/i,
      /sent from my iphone/i,
      /inviato da/i
    ];
    
    for (const marker of sigMarkers) {
      const match = result.search(marker);
      if (match !== -1) {
        result = result.substring(0, match);
        break;
      }
    }
    
    return result.trim();
  }
  
  // ========================================================================
  // INVIO RISPOSTA
  // ========================================================================
  
  /**
   * Invia risposta a un thread
   * âœ… Usa sender_email che include Reply-To quando presente
   */
  sendReply(thread, replyText, messageDetails) {
    // Ottieni oggetto GmailThread se Ã¨ un ID
    const gmailThread = typeof thread === 'string' ? 
                        GmailApp.getThreadById(thread) : thread;
    
    // Rispondi al thread (Gmail gestisce il threading automaticamente)
    gmailThread.reply(replyText);
    
    console.log(`âœ“ Reply sent to ${messageDetails.senderEmail}`);
    
    if (messageDetails.hasReplyTo) {
      console.log('   ðŸ“§ Reply sent to Reply-To address');
    }
    
    return true;
  }
  
  /**
   * Invia risposta come HTML (per risposte formattate)
   * âœ… Applica safeguard di formattazione (funzionalitÃ  legacy)
   * âœ… Applica sostituzioni personalizzate dal foglio Sostituzioni
   */
  sendHtmlReply(thread, responseText, messageDetails) {
    // 0. Applica Sostituzioni Personalizzate (dal foglio Sostituzioni)
    let finalResponse = responseText;
    if (typeof GLOBAL_CACHE !== 'undefined' && GLOBAL_CACHE.replacements) {
      const replacementCount = Object.keys(GLOBAL_CACHE.replacements).length;
      if (replacementCount > 0) {
        finalResponse = this.applyReplacements(finalResponse, GLOBAL_CACHE.replacements);
        console.log(`   âœ“ Applied ${replacementCount} replacement rules`);
      }
    }
    
    // 1. Applica Safeguard di Formattazione
    finalResponse = this.fixPunctuation(finalResponse, messageDetails.senderName);
    finalResponse = this.ensureGreetingLineBreak(finalResponse);

    // 2. Converti in HTML e invia
    const gmailThread = typeof thread === 'string'
      ? GmailApp.getThreadById(thread)
      : thread;

    try {
      const htmlBody = markdownToHtml(finalResponse);
      gmailThread.reply('', { htmlBody: htmlBody });
      console.log(`âœ“ HTML reply sent to ${messageDetails.senderEmail}`);
    } catch (error) {
      console.error(`âŒ Markdown conversion failed: ${error.message}`);
      // Fallback: invia come testo plain
      gmailThread.reply(finalResponse);
      console.log(`âœ“ Plain text reply sent to ${messageDetails.senderEmail} (fallback)`);
    }
  }

  // ========================================================================
  // SAFEGUARD DI FORMATTAZIONE (FunzionalitÃ  Legacy)
  // ========================================================================

  /**
   * Corregge errori comuni di punteggiatura
   * Es. "Buongiorno, Siamo" -> "Buongiorno, siamo"
   * 
   * COMPORTAMENTO:
   * - Corregge maiuscole dopo virgola (es. "Siamo" -> "siamo")
   * - Eccezioni: titoli (Don, Padre, ecc.) e nome mittente
   * - âœ… NON tocca parole tra due virgole (vocativo: ", Federica,")
   */
  fixPunctuation(text, senderName = '') {
    if (!text) return text;
    
    // Parole che DEVONO rimanere maiuscole dopo virgola
    const exceptions = ['Don', 'Padre', 'Suor', 'Monsignor', 'Papa', 'Signore', 'Signora'];
    
    // Aggiungi nome mittente alle eccezioni
    if (senderName) {
      const nameParts = senderName.split(/\s+/);
      for (const part of nameParts) {
        if (part && !exceptions.includes(part)) {
          exceptions.push(part);
        }
      }
    }
    
    // Fix: minuscola dopo virgola (escluse eccezioni e vocativi tra virgole)
    return text.replace(/,\s+([A-ZÃ€ÃˆÃ‰ÃŒÃ’Ã™])([a-zÃ Ã¨Ã©Ã¬Ã²Ã¹]*)/g, (match, firstLetter, rest, offset) => {
      const word = firstLetter + rest;
      
      // Eccezione 1: titoli e nome mittente
      if (exceptions.includes(word)) {
        return match;
      }
      
      // Eccezione 2: vocativo tra virgole (es. ", Federica,")
      // Controlla se dopo la parola c'Ã¨ una virgola
      const afterMatch = text.substring(offset + match.length);
      if (afterMatch.match(/^\s*,/)) {
        // Ãˆ un vocativo, non minuscolizzare
        return match;
      }
      
      return `, ${firstLetter.toLowerCase()}${rest}`;
    });
  }

  /**
   * Assicura che ci sia una riga vuota dopo il saluto
   */
  ensureGreetingLineBreak(text) {
    if (!text) return text;

    // Pattern: Riga saluto (inizio stringa, alcune parole, virgola/esclamativo, a capo)
    // Seguito da testo immediato senza riga vuota.
    
    // E.g. ^Buongiorno, \nSiamo... -> ^Buongiorno, \n\nSiamo...
    
    const lines = text.split('\n');
    if (lines.length > 1) {
      const firstLine = lines[0].trim();
      // Verifica se sembra un saluto
      if (/^(Buongiorno|Buonasera|Salve|Gentile|Egregio|Ciao)/i.test(firstLine)) {
        // Verifica se la seconda riga NON Ã¨ vuota
        if (lines[1].trim() !== '') {
            // Inserisci riga vuota
            lines.splice(1, 0, '');
            return lines.join('\n');
        }
      }
    }
    return text;
  }

  /**
   * Applies custom text replacements from the Sostituzioni sheet
   * @param {string} text - Text to apply replacements to
   * @param {Object} replacements - Map of {badText: goodText}
   */
  applyReplacements(text, replacements) {
    if (!text || !replacements) return text;
    
    let result = text;
    for (const [bad, good] of Object.entries(replacements)) {
      // Sostituzione globale case insensitive
      const regex = new RegExp(bad.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
      result = result.replace(regex, good);
    }
    return result;
  }

  // ========================================================================
  // VERIFICA STATO
  // ========================================================================
  
  /**
   * Testa accesso Gmail
   */
  testConnection() {
    const results = {
      connectionOk: false,
      canListMessages: false,
      canCreateLabels: false,
      errors: []
    };
    
    try {
      // Testa listing thread
      const threads = GmailApp.search('is:unread', 0, 1);
      results.connectionOk = true;
      results.canListMessages = true;
      
      // Testa creazione etichette
      try {
        const testLabel = this.getOrCreateLabel('_TEST_LABEL_');
        results.canCreateLabels = true;
        
        // Pulizia
        try {
          testLabel.deleteLabel();
        } catch (e) {
          // Non critico
        }
      } catch (e) {
        results.errors.push(`Cannot create labels: ${e.message}`);
      }
      
    } catch (e) {
      results.errors.push(`Connection error: ${e.message}`);
    }
    
    results.isHealthy = results.connectionOk && results.canListMessages;
    return results;
  }
}

// Funzione factory
function createGmailService() {
  return new GmailService();
}

// ====================================================================
// MARKDOWN â†’ HTML (GLOBAL, REQUIRED BY GmailService)
// Ripristina stile originale: viola + font 20px
// ====================================================================

function markdownToHtml(text) {
  if (!text) return '';

  let html = text;

  // âœ… STEP 1: Proteggi code blocks PRIMA di tutto
  const codeBlocks = [];
  html = html.replace(/```[\s\S]*?```/g, (match) => {
    codeBlocks.push(match);
    return `__CODEBLOCK_${codeBlocks.length - 1}__`;
  });

  // âœ… STEP 2: Converti links PRIMA di escape (preserva URL intatti)
  html = html.replace(/\[(.+?)\]\((.+?)\)/g, (match, linkText, url) => {
    // Escape solo il testo del link, NON l'URL
    const escapedText = linkText
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    return `<a href="${url}" style="color:#351c75;">${escapedText}</a>`;
  });

  // âœ… STEP 3: Headers (markdown â†’ HTML)
  html = html.replace(/^###\s+(.+)$/gm, '<p style="font-size:16px;font-weight:bold;">$1</p>');
  html = html.replace(/^##\s+(.+)$/gm, '<p style="font-size:18px;font-weight:bold;">$1</p>');
  html = html.replace(/^#\s+(.+)$/gm, '<p style="font-size:20px;font-weight:bold;">$1</p>');

  // âœ… STEP 4: Bold / Italic
  html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  html = html.replace(/(?<!\*)\*(?!\*)(.+?)\*(?!\*)/g, '<em>$1</em>');

  // âœ… STEP 5: Escape testo rimanente (dopo conversione markdown)
  // Split by HTML tags to escape only text content
  html = html.replace(/>[^<]+</g, (match) => {
    return match.slice(0, 1) + 
           match.slice(1, -1)
             .replace(/&(?!amp;|lt;|gt;|quot;|#\d+;)/g, '&amp;')
             .replace(/<(?![^>]*>)/g, '&lt;')
             .replace(/(?<![^<]*)>/g, '&gt;') + 
           match.slice(-1);
  });

  // âœ… STEP 6: Restore code blocks (con escape interno)
  codeBlocks.forEach((block, i) => {
    const code = block.replace(/```/g, '').trim()
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    html = html.replace(
      `__CODEBLOCK_${i}__`,
      `<pre style="background:#f4f4f4;padding:10px;border-radius:4px;font-family:monospace;">${code}</pre>`
    );
  });

  // âœ… STEP 7: Paragraphs and line breaks
  html = html.replace(/\n\n+/g, '</p><p>');
  html = html.replace(/\n/g, '<br>');

  // âœ… STEP 8: Convert emojis to HTML entities
  html = html.replace(/[^\x00-\x7F]/g, char => {
    return '&#' + char.codePointAt(0) + ';';
  });

  // Wrapper finale
  return `
    <div style="
      font-family: Arial, Helvetica, sans-serif;
      font-size: 20px;
      color: #351c75;
      line-height: 1.6;
    ">
      <p>${html}</p>
    </div>
  `;
}
