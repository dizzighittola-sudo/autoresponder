// ====================================================================
// GEMINI RATE LIMITER - Gestione Quote API
// ====================================================================
// 
// ‚úÖ SINCRONO - Compatibile con Google Apps Script
// ‚úÖ Configurazione modelli centralizzata in Main.txt
// ‚úÖ Reset quota: ore 9:00 italiane (mezzanotte Pacific)
// ‚úÖ Cache ottimizzata per ridurre letture PropertiesService
// ====================================================================

/**
 * GeminiRateLimiter - Gestione intelligente quote API Gemini
 * 
 * CONFIGURAZIONE:
 *   I modelli e le quote sono definiti in Main.txt ‚Üí CONFIG.GEMINI_MODELS
 *   La strategia di selezione √® in Main.txt ‚Üí CONFIG.MODEL_STRATEGY
 * 
 * FUNZIONALIT√Ä:
 *   - Traccia utilizzo RPM (richieste/minuto), TPM (token/minuto), RPD (richieste/giorno)
 *   - Seleziona automaticamente il modello disponibile
 *   - Applica throttling quando ci si avvicina ai limiti
 *   - Passa al modello di riserva se il principale √® esaurito
 * 
 * NOTA: Il reset delle quote Google avviene alle 9:00 ora italiana
 */
class GeminiRateLimiter {
  constructor() {
    console.log('üö¶ Inizializzazione GeminiRateLimiter...');
    
    // ================================================================
    // CONFIGURAZIONE MODELLI (Legge da CONFIG in Main.txt)
    // ================================================================
    
    // ‚úÖ CENTRALIZZATO: Legge modelli da CONFIG.GEMINI_MODELS
    if (typeof CONFIG !== 'undefined' && CONFIG.GEMINI_MODELS) {
      this.models = CONFIG.GEMINI_MODELS;
      console.log('   ‚úì Modelli caricati da CONFIG.GEMINI_MODELS');
    } else {
      // Fallback se CONFIG non disponibile
      console.warn('   ‚ö†Ô∏è CONFIG.GEMINI_MODELS non trovato, uso default');
      this.models = {
        'flash-2.5': {
          name: 'gemini-2.5-flash',
          rpm: 15, tpm: 250000, rpd: 250,
          useCases: ['generation', 'quick_check', 'all']
        },
        'flash-1.5': {
          name: 'gemini-1.5-flash',
          rpm: 15, tpm: 1000000, rpd: 1500,
          useCases: ['fallback', 'high_volume']
        }
      };
    }
    
    // ‚úÖ CENTRALIZZATO: Legge strategia da CONFIG.MODEL_STRATEGY
    if (typeof CONFIG !== 'undefined' && CONFIG.MODEL_STRATEGY) {
      this.strategies = CONFIG.MODEL_STRATEGY;
      console.log('   ‚úì Strategia caricata da CONFIG.MODEL_STRATEGY');
    } else {
      // Fallback default
      this.strategies = {
        'quick_check': ['flash-2.5', 'flash-1.5'],
        'generation': ['flash-2.5', 'flash-1.5'],
        'fallback': ['flash-1.5', 'flash-2.5']
      };
    }
    
    // Modello di default (primo nella lista generation)
    this.defaultModel = Object.keys(this.models)[0] || 'flash-2.5';
    
    // ================================================================
    // CACHE IN-MEMORY (per ridurre PropertiesService reads)
    // ================================================================
    
    this.cache = {
      rpmWindow: [],
      tpmWindow: [],
      lastCacheUpdate: 0,
      cacheTTL: 10000  // 10 secondi cache TTL
    };
    
    // ================================================================
    // PERSISTENCE (PropertiesService)
    // ================================================================
    
    this.props = PropertiesService.getScriptProperties();
    
    // Inizializza contatori se non esistono
    this._initializeCounters();
    
    // ================================================================
    // THROTTLING CONFIGURATION
    // ================================================================
    
    this.safetyMargin = {
      rpm: 0.8,   // 80% del limite (12 su 15)
      tpm: 0.8,
      rpd: 0.9    // 90% del limite
    };
    
    this.throttleDelays = {
      rpm: 5000,   // 5 secondi
      tpm: 3000,
      rpd: 10000
    };
    
    // Exponential backoff
    this.backoffBase = 2000;
    this.backoffMultiplier = 2;
    this.maxBackoff = 60000;
    
    console.log('‚úì GeminiRateLimiter v2.1 inizializzato');
    console.log(`   Modelli: ${Object.keys(this.models).join(', ')}`);
    console.log(`   Default: ${this.defaultModel}`);
  }
  
  // ================================================================
  // INITIALIZATION
  // ================================================================
  
  _initializeCounters() {
    const today = this._getItalianDate();
    const currentDate = this.props.getProperty('rate_limit_date');
    
    // Reset giornaliero (9:00 AM italiana = midnight Pacific)
    if (currentDate !== today) {
      console.log(`üìÖ New day (${today}), resetting daily counters`);
      this._resetDailyCounters();
      this.props.setProperty('rate_limit_date', today);
    }
  }
  
  _resetDailyCounters() {
    for (const modelKey in this.models) {
      this.props.setProperty(`rpd_${modelKey}`, '0');
      this.props.setProperty(`tokens_${modelKey}`, '0');
    }
    // Reset anche cache
    this.props.setProperty('rpm_window', JSON.stringify([]));
    this.props.setProperty('tpm_window', JSON.stringify([]));
    console.log('‚úì Daily counters reset');
  }
  
  /**
   * Get data in formato italiano (per logging user-friendly)
   * NOTA: Reset quota avviene a mezzanotte Pacific = 9:00 AM italiana
   */
  _getItalianDate() {
    const now = new Date();
    // Ottieni data italiana corrente
    const italianDate = Utilities.formatDate(now, 'Europe/Rome', 'yyyy-MM-dd');
    return italianDate;
  }
  
  /**
   * Check se siamo dopo le 9:00 AM (quando avviene reset Pacific)
   */
  _isAfterPacificReset() {
    const now = new Date();
    const hour = parseInt(Utilities.formatDate(now, 'Europe/Rome', 'HH'));
    return hour >= 9;  // Reset Pacific = 9:00 AM italiana
  }
  
  // ================================================================
  // MODEL SELECTION (Sincrono)
  // ================================================================
  
  selectModel(taskType, options) {
    options = options || {};
    const preferQuality = options.preferQuality || false;
    const forceModel = options.forceModel || null;
    const estimatedTokens = options.estimatedTokens || 1000;
    
    // Override manuale
    if (forceModel && this.models[forceModel]) {
      return this._validateModelAvailability(forceModel, estimatedTokens);
    }
    
    // ‚úÖ Usa strategia da CONFIG (o fallback)
    // Aggiunge 'classification' come alias di 'quick_check' se non definito
    const taskStrategies = this.strategies;
    if (!taskStrategies['classification']) {
      taskStrategies['classification'] = taskStrategies['quick_check'] || ['flash-2.5', 'flash-1.5'];
    }
    
    const candidates = taskStrategies[taskType] || taskStrategies['fallback'] || ['flash-2.5', 'flash-1.5'];
    
    // Trova primo modello disponibile
    for (var i = 0; i < candidates.length; i++) {
      const modelKey = candidates[i];
      const result = this._validateModelAvailability(modelKey, estimatedTokens);
      if (result.available) {
        console.log(`‚úì Selezionato: ${modelKey} per ${taskType}`);
        console.log(`   RPD rimanenti: ${result.quotaLeft.rpd}/${this.models[modelKey].rpd}`);
        return result;
      }
    }
    
    // Nessun modello disponibile
    console.error('‚ùå NESSUN MODELLO DISPONIBILE');
    return {
      available: false,
      modelKey: null,
      reason: 'all_quotas_exhausted',
      nextResetTime: this._getNextResetTime()
    };
  }
  
  _validateModelAvailability(modelKey, estimatedTokens) {
    const model = this.models[modelKey];
    if (!model) {
      return {available: false, reason: 'model_not_found'};
    }
    
    // Check RPD
    const rpdUsed = parseInt(this.props.getProperty(`rpd_${modelKey}`) || '0');
    const rpdLeft = model.rpd - rpdUsed;
    
    if (rpdLeft <= 0) {
      return {
        available: false,
        modelKey: modelKey,
        reason: 'rpd_exhausted',
        quotaLeft: {rpd: 0}
      };
    }
    
    // Check RPM (ultimo minuto)
    const rpmUsed = this._getRequestsInWindow('rpm', modelKey);
    const rpmLeft = model.rpm - rpmUsed;
    
    if (rpmLeft <= 0) {
      return {
        available: false,
        modelKey: modelKey,
        reason: 'rpm_exhausted',
        retryAfter: 60
      };
    }
    
    // Check TPM (ultimo minuto)
    const tpmUsed = this._getTokensInWindow('tpm', modelKey);
    const tpmLeft = model.tpm - tpmUsed;
    
    if (tpmLeft < estimatedTokens) {
      return {
        available: false,
        modelKey: modelKey,
        reason: 'tpm_insufficient',
        quotaLeft: {tpm: tpmLeft},
        retryAfter: 60
      };
    }
    
    // Modello disponibile
    return {
      available: true,
      modelKey: modelKey,
      model: model,
      quotaLeft: {
        rpd: rpdLeft,
        rpm: rpmLeft,
        tpm: tpmLeft
      },
      shouldThrottle: this._shouldThrottle(modelKey, rpdUsed, rpmUsed, tpmUsed)
    };
  }
  
  _shouldThrottle(modelKey, rpdUsed, rpmUsed, tpmUsed) {
    const model = this.models[modelKey];
    
    const rpdRatio = rpdUsed / model.rpd;
    const rpmRatio = rpmUsed / model.rpm;
    const tpmRatio = tpmUsed / model.tpm;
    
    if (rpdRatio >= this.safetyMargin.rpd) {
      return {needed: true, reason: 'rpd', delay: this.throttleDelays.rpd};
    }
    if (rpmRatio >= this.safetyMargin.rpm) {
      return {needed: true, reason: 'rpm', delay: this.throttleDelays.rpm};
    }
    if (tpmRatio >= this.safetyMargin.tpm) {
      return {needed: true, reason: 'tpm', delay: this.throttleDelays.tpm};
    }
    
    return {needed: false};
  }
  
  // ================================================================
  // REQUEST EXECUTION (‚úÖ SINCRONO - No async/await)
  // ================================================================
  
  /**
   * Esegue richiesta con rate limiting
   * ‚úÖ VERSIONE SINCRONA per Google Apps Script
   * 
   * @param {string} taskType - Tipo task: 'quick_check', 'generation', etc.
   * @param {Function} requestFn - Funzione che riceve modelName ed esegue la richiesta
   * @param {Object} options - {estimatedTokens, maxRetries, preferQuality}
   * @returns {Object} {success, result, modelUsed, quotaUsed}
   */
  executeRequest(taskType, requestFn, options) {
    options = options || {};
    const estimatedTokens = options.estimatedTokens || 1000;
    const maxRetries = options.maxRetries || 3;
    const preferQuality = options.preferQuality || false;
    
    // 1. Model selection
    const selection = this.selectModel(taskType, {
      estimatedTokens: estimatedTokens,
      preferQuality: preferQuality
    });
    
    if (!selection.available) {
      console.error(`‚ùå No model available: ${selection.reason}`);
      throw new Error('QUOTA_EXHAUSTED: ' + selection.reason);
    }
    
    const modelKey = selection.modelKey;
    const model = selection.model;
    const shouldThrottle = selection.shouldThrottle;
    
    // 2. Throttling
    if (shouldThrottle && shouldThrottle.needed) {
      console.warn(`‚è∏Ô∏è  Throttling (${shouldThrottle.reason}): ${shouldThrottle.delay}ms`);
      Utilities.sleep(shouldThrottle.delay);
    }
    
    // 3. Execute con retry (‚úÖ sincrono)
    var lastError = null;
    for (var attempt = 0; attempt < maxRetries; attempt++) {
      try {
        const startTime = Date.now();
        
        console.log(`üöÄ Tentativo richiesta ${attempt + 1}/${maxRetries}`);
        console.log(`   Modello: ${model.name}, Task: ${taskType}`);
        
        // ‚úÖ CHIAMATA SINCRONA (no await)
        const result = requestFn(model.name);
        
        const duration = Date.now() - startTime;
        
        // Track successful request
        this._trackRequest(modelKey, estimatedTokens, duration);
        
        console.log(`‚úì Successo (${duration}ms)`);
        
        return {
          success: true,
          result: result,
          modelUsed: model.name,
          modelKey: modelKey,
          duration: duration,
          quotaUsed: {
            rpd: parseInt(this.props.getProperty(`rpd_${modelKey}`)),
            rpm: this._getRequestsInWindow('rpm', modelKey)
          }
        };
        
      } catch (error) {
        lastError = error;
        const errorMsg = error.message || '';
        
        // Check if 429
        if (errorMsg.indexOf('429') !== -1 || 
            errorMsg.indexOf('rate limit') !== -1 || 
            errorMsg.indexOf('quota') !== -1) {
          
          console.warn(`‚ö†Ô∏è  Limite quota (429) al tentativo ${attempt + 1}`);
          
          if (attempt < maxRetries - 1) {
            const backoffDelay = Math.min(
              this.backoffBase * Math.pow(this.backoffMultiplier, attempt),
              this.maxBackoff
            );
            console.log(`   Attesa ${backoffDelay}ms...`);
            Utilities.sleep(backoffDelay);
            continue;
          }
        } else {
          // Errore non ritentabile
          throw error;
        }
      }
    }
    
    // Tutti i tentativi falliti
    console.error(`‚ùå Tutti i ${maxRetries} tentativi falliti`);
    throw lastError || new Error('Richiesta fallita dopo tutti i tentativi');
  }
  
  // ================================================================
  // TRACKING (Ottimizzato con cache)
  // ================================================================
  
  _trackRequest(modelKey, tokensUsed, duration) {
    const now = Date.now();
    
    // 1. RPD counter
    const rpdKey = 'rpd_' + modelKey;
    const currentRpd = parseInt(this.props.getProperty(rpdKey) || '0');
    this.props.setProperty(rpdKey, (currentRpd + 1).toString());
    
    // 2. Token counter
    const tokensKey = 'tokens_' + modelKey;
    const currentTokens = parseInt(this.props.getProperty(tokensKey) || '0');
    this.props.setProperty(tokensKey, (currentTokens + tokensUsed).toString());
    
    // 3. RPM window (con cache)
    this._updateWindow('rpm', {
      timestamp: now,
      modelKey: modelKey
    });
    
    // 4. TPM window (con cache)
    this._updateWindow('tpm', {
      timestamp: now,
      modelKey: modelKey,
      tokens: tokensUsed
    });
    
    // Log
    console.log(`üìä Tracciato: ${modelKey}`);
    console.log(`   RPD: ${currentRpd + 1}/${this.models[modelKey].rpd}`);
  }
  
  /**
   * Update window con cache (riduce PropertiesService I/O)
   */
  _updateWindow(windowType, entry) {
    const now = Date.now();
    
    // Invalida cache se troppo vecchia
    if (now - this.cache.lastCacheUpdate > this.cache.cacheTTL) {
      this._refreshCache();
    }
    
    // Aggiungi a cache
    const cacheKey = windowType + 'Window';
    this.cache[cacheKey].push(entry);
    
    // Pulisci vecchie entry (>60 secondi)
    this.cache[cacheKey] = this.cache[cacheKey].filter(function(e) {
      return now - e.timestamp < 60000;
    });
    
    // Persist ogni 10 secondi (batch writes)
    if (now - this.cache.lastCacheUpdate > 10000) {
      this._persistCache();
    }
  }
  
  _refreshCache() {
    const rpmWindow = JSON.parse(this.props.getProperty('rpm_window') || '[]');
    const tpmWindow = JSON.parse(this.props.getProperty('tpm_window') || '[]');
    
    const now = Date.now();
    
    // Pulisci vecchie entry
    this.cache.rpmWindow = rpmWindow.filter(function(e) {
      return now - e.timestamp < 60000;
    });
    this.cache.tpmWindow = tpmWindow.filter(function(e) {
      return now - e.timestamp < 60000;
    });
    
    this.cache.lastCacheUpdate = now;
  }
  
  _persistCache() {
    this.props.setProperty('rpm_window', JSON.stringify(this.cache.rpmWindow));
    this.props.setProperty('tpm_window', JSON.stringify(this.cache.tpmWindow));
    this.cache.lastCacheUpdate = Date.now();
  }
  
  _getRequestsInWindow(windowType, modelKey) {
    const now = Date.now();
    
    // Usa cache se fresh
    if (now - this.cache.lastCacheUpdate < this.cache.cacheTTL) {
      const cacheKey = windowType + 'Window';
      return this.cache[cacheKey].filter(function(e) {
        return e.modelKey === modelKey && (now - e.timestamp < 60000);
      }).length;
    }
    
    // Altrimenti leggi da PropertiesService
    const window = JSON.parse(this.props.getProperty(windowType + '_window') || '[]');
    return window.filter(function(e) {
      return e.modelKey === modelKey && (now - e.timestamp < 60000);
    }).length;
  }
  
  _getTokensInWindow(windowType, modelKey) {
    const now = Date.now();
    
    // Usa cache
    if (now - this.cache.lastCacheUpdate < this.cache.cacheTTL) {
      return this.cache.tpmWindow
        .filter(function(e) {
          return e.modelKey === modelKey && (now - e.timestamp < 60000);
        })
        .reduce(function(sum, e) { return sum + (e.tokens || 0); }, 0);
    }
    
    // Fallback PropertiesService
    const window = JSON.parse(this.props.getProperty('tpm_window') || '[]');
    return window
      .filter(function(e) {
        return e.modelKey === modelKey && (now - e.timestamp < 60000);
      })
      .reduce(function(sum, e) { return sum + (e.tokens || 0); }, 0);
  }
  
  // ================================================================
  // STATISTICS
  // ================================================================
  
  getUsageStats() {
    const stats = {
      date: this._getItalianDate(),
      italianTime: Utilities.formatDate(new Date(), 'Europe/Rome', 'HH:mm'),
      nextReset: this._getNextResetTime(),
      models: {}
    };
    
    for (var modelKey in this.models) {
      const model = this.models[modelKey];
      const rpdUsed = parseInt(this.props.getProperty('rpd_' + modelKey) || '0');
      const tokensUsed = parseInt(this.props.getProperty('tokens_' + modelKey) || '0');
      const rpmUsed = this._getRequestsInWindow('rpm', modelKey);
      const tpmUsed = this._getTokensInWindow('tpm', modelKey);
      
      stats.models[modelKey] = {
        name: model.name,
        rpd: {
          used: rpdUsed, 
          limit: model.rpd, 
          percent: (rpdUsed / model.rpd * 100).toFixed(1)
        },
        rpm: {
          used: rpmUsed, 
          limit: model.rpm, 
          percent: (rpmUsed / model.rpm * 100).toFixed(1)
        },
        tpm: {
          used: tpmUsed, 
          limit: model.tpm, 
          percent: (tpmUsed / model.tpm * 100).toFixed(1)
        },
        tokensToday: tokensUsed
      };
    }
    
    return stats;
  }
  
  logUsageStats() {
    const stats = this.getUsageStats();
    
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('üìä GEMINI QUOTA USAGE - ' + stats.date + ' ' + stats.italianTime);
    console.log('‚è∞ Next reset: ' + stats.nextReset + ' (9:00 AM italiana)');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    
    for (var modelKey in stats.models) {
      const model = stats.models[modelKey];
      console.log('\n' + modelKey.toUpperCase() + ' (' + model.name + '):');
      console.log('  RPD: ' + model.rpd.used + '/' + model.rpd.limit + ' (' + model.rpd.percent + '%)');
      console.log('  RPM: ' + model.rpm.used + '/' + model.rpm.limit + ' (' + model.rpm.percent + '%)');
      console.log('  Tokens today: ' + model.tokensToday.toLocaleString());
    }
    
    console.log('\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
  }
  
  _getNextResetTime() {
    const now = new Date();
    const hour = parseInt(Utilities.formatDate(now, 'Europe/Rome', 'HH'));
    
    if (hour < 9) {
      // Reset oggi alle 9:00
      return 'oggi alle 9:00 AM';
    } else {
      // Reset domani alle 9:00
      return 'domani alle 9:00 AM';
    }
  }
}

// ================================================================
// FUNZIONI UTILIT√Ä (per dashboard e manutenzione)
// ================================================================

/**
 * Dashboard quota (esegui manualmente da editor script)
 */
function showQuotaDashboard() {
  const limiter = new GeminiRateLimiter();
  limiter.logUsageStats();
  
  // Avviso se >80%
  const stats = limiter.getUsageStats();
  for (var modelKey in stats.models) {
    const model = stats.models[modelKey];
    if (parseFloat(model.rpd.percent) > 80) {
      console.warn('‚ö†Ô∏è  ATTENZIONE: ' + modelKey + ' RPD > 80% (' + model.rpd.percent + '%)');
    }
  }
}

/**
 * Reset manuale contatori (usare con cautela!)
 */
function resetQuotaCounters() {
  const limiter = new GeminiRateLimiter();
  limiter._resetDailyCounters();
  limiter.props.setProperty('rate_limit_date', limiter._getItalianDate());
  console.log('‚úì Contatori quota resettati manualmente');
}
