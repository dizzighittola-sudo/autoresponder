// ====================================================================
// GEMINI SERVICE - Servizio API Gemini
// ‚úÖ RETRY con exponential backoff
// ‚úÖ Language detection centralizzata
// ‚úÖ Quick check per decidere se rispondere
// ====================================================================

/**
 * GeminiService - Servizio interazione con API Gemini
 * 
 * KEY FEATURES:
 * ‚úÖ Retry con exponential backoff (3 tentativi)
 * ‚úÖ Rilevamento lingua centralizzato
 * ‚úÖ Quick check per should_respond + lingua
 * ‚úÖ Saluto adattivo per ora e lingua
 */
class GeminiService {
  constructor() {
    console.log('ü§ñ Inizializzazione GeminiService...');
    
    // Ottieni configurazione
    this.apiKey = typeof CONFIG !== 'undefined' ? CONFIG.GEMINI_API_KEY : 
                  PropertiesService.getScriptProperties().getProperty('GEMINI_API_KEY');
    this.modelName = typeof CONFIG !== 'undefined' ? CONFIG.MODEL_NAME : 'gemini-2.5-flash';
    this.baseUrl = `https://generativelanguage.googleapis.com/v1beta/models/${this.modelName}:generateContent`;
    
    if (!this.apiKey || this.apiKey.length < 20) {
      throw new Error('GEMINI_API_KEY non configurata correttamente');
    }
    
    // Configurazione retry (ottimizzato BUG 13)
    this.maxRetries = 3;
    this.retryDelay = 2000; // ms (2 secondi - bilanciato per UX e rate limit)
    this.backoffFactor = 1.5; // crescita graduale: 2s ‚Üí 3s ‚Üí 4.5s
    
    console.log(`‚úì GeminiService inizializzato con modello: ${this.modelName}`);
  }
  
  // ========================================================================
  // WRAPPER RETRY
  // ========================================================================
  
  /**
   * Esegue funzione con retry ed exponential backoff
   */
  _withRetry(fn, context = 'API call') {
    for (let attempt = 0; attempt < this.maxRetries; attempt++) {
      try {
        return fn();
      } catch (error) {
        const msg = error && error.message ? error.message : '';
        const isRetryable = msg && (
          msg.includes('timeout') ||
          msg.includes('503') ||
          msg.includes('429') ||
          msg.includes('rate limit')
        );
        
        if (isRetryable && attempt < this.maxRetries - 1) {
          const waitTime = this.retryDelay * Math.pow(this.backoffFactor, attempt);
          console.warn(`‚ö†Ô∏è ${context} failed (attempt ${attempt + 1}/${this.maxRetries}): ${error.message}`);
          console.log(`   Retrying in ${waitTime / 1000}s...`);
          Utilities.sleep(waitTime);
        } else if (attempt === this.maxRetries - 1) {
          console.error(`‚ùå All ${this.maxRetries} ${context} attempts failed`);
          throw error;
        } else {
          // Errore non ritentabile
          throw error;
        }
      }
    }
  }
  
  // ========================================================================
  // RILEVAMENTO LINGUA (Centralizzato)
  // ========================================================================
  
  /**
   * Rileva lingua email con detection avanzata
   * ‚úÖ CENTRALIZZATO: Unico punto per rilevamento lingua
   * ‚úÖ AGGIORNATO: Migliorata logica di scoring e aggiunta lingua tedesca
   */
  detectEmailLanguage(emailContent, emailSubject) {
    const text = `${emailSubject} ${emailContent}`.toLowerCase();
    const originalText = `${emailSubject} ${emailContent}`;
    
    // Rilevamento caratteri specifici spagnoli (altamente distintivi)
    // FIX Bug 5: Peso ridotto per evitare falsi positivi con nomi spagnoli in email italiane
    let spanishCharScore = 0;
    if (originalText.includes('¬ø') || originalText.includes('¬°')) {
      spanishCharScore = 3; // Ridotto da 5 per evitare collisioni
      console.log('   Found Spanish-specific punctuation (¬ø or ¬°)');
    }
    if (text.includes('√±')) {
      spanishCharScore += 2; // Ridotto da 3 per evitare collisioni con nomi spagnoli
      console.log('   Found Spanish-specific character (√±)');
    }
    

    
    // Parole chiave per rilevamento
    const englishUniqueKeywords = [
      'the', 'would', 'could', 'should', 'might',
      'we are', 'you are', 'they are', 'i am', "i'm", "we're", "you're",
      'please', 'thank you', 'thanks', 'dear sir', 'dear madam',
      'kind regards', 'best regards', 'sincerely', 'yours truly',
      'looking forward', 'i would like', 'we would like',
      'let me know', 'get back to', 'reach out',
      'however', 'therefore', 'furthermore', 'moreover',
      'regarding', 'concerning', 'attached', 'enclosed',
      'schedule', 'meeting', 'appointment', 'available'
    ];
    
    const englishStandardKeywords = [
      ' and ', ' but ', ' an ',
      'will', 'can', 'may', 'shall', 'must',
      'have', 'has', 'had', 'do', 'does', 'did',
      'send', 'get', 'want', 'need', 'make', 'give', 'take',
      'what', 'when', 'where', 'how', 'why', 'which', 'who',
      ' on ', ' of ', ' to ', ' from ', ' for ', ' with ', ' at ', ' by ',
      'website', 'business', 'offer', 'service', 'services',
      'information', 'email', 'contact', 'phone',
      'good', 'best', 'first', 'your', 'our', 'this', 'that',
      'also', 'just', 'about', 'very', 'much', 'more', 'some'
    ];
    
    const spanishKeywords = [
      'he ido', 'hab√≠a', 'hay', 'ido', 'sido',
      'hacer', 'haber', 'poder', 'estar', 'estoy', 'est√°n',
      'por qu√©', 'porque', 'cu√°ndo', 'c√≥mo', 'd√≥nde', 'qu√© tal',
      'por favor', 'muchas gracias', 'buenos d√≠as', 'buenas tardes',
      'querido', 'estimado', 'saludos',
      ' no ', ' un ', ' unos ', ' unas ',
      ' del ', ' con el ', ' en el ', ' es ',
      'somos', 'proyecto', 'informaci√≥n', 'quiero', 'quisiera', 'necesito',
      'que', 'cuando', 'quien', 'tambien', 'para', 'por',
      ' y ', 'sus', 'hola', 'los', 'las', 'el ',
      'informacion', 'favor', 'muy', 'usted', 'ahora', 'aqui', 'gracias'
    ];
    
    const italianKeywords = [
      'sono', 'siamo', 'stato', 'stata', 'ho', 'hai', 'abbiamo',
      'fare', 'avere', 'essere', 'potere', 'volere',
      'perch√©', 'perch√®', 'quando', 'come', 'dove', 'cosa',
      'per favore', 'per piacere', 'molte grazie', 'buongiorno',
      'buonasera', 'gentile', 'egregio', 'cordiali saluti',
      ' non ', ' il ', ' di ', ' da ',
      ' nel ', ' della ', ' degli ', ' delle ',
      'progetto', 'informazione', 'informazioni', 'vorrei', 'gradirei'
    ];
    

    
    // Conta corrispondenze con limiti di parola
    const countMatches = (keywords, txt, weight = 1) => {
      let count = 0;
      for (const kw of keywords) {
        if (kw.startsWith(' ') || kw.endsWith(' ')) {
          // Match sottostringa per frasi con spazi espliciti
          const matches = (txt.match(new RegExp(kw.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi')) || []).length;
          count += weight * matches;
        } else {
          // Match con limiti di parola
          const escaped = kw.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          const pattern = new RegExp(`\\b${escaped}\\b`, 'gi');
          const matches = (txt.match(pattern) || []).length;
          count += weight * matches;
        }
      }
      return count;
    };
    
    const englishScore = countMatches(englishUniqueKeywords, text, 2) + 
                         countMatches(englishStandardKeywords, text, 1);
    
    const scores = {
      'en': englishScore,
      'es': countMatches(spanishKeywords, text, 1) + spanishCharScore,
      'it': countMatches(italianKeywords, text, 1)
    };
    
    console.log(`   Language scores: EN=${scores['en']}, ES=${scores['es']}, IT=${scores['it']}`);
    
    // Determina lingua rilevata
    let detectedLang = 'it';
    let maxScore = 0;
    for (const lang in scores) {
      if (scores[lang] > maxScore) {
        maxScore = scores[lang];
        detectedLang = lang;
      }
    }
    
    // Logica soglia confidenza
    // Logica soglia confidenza
    if (spanishCharScore > 0 && scores['es'] >= scores['it'] && scores['es'] >= scores['en']) {
      console.log(`   ‚úì Detected: SPANISH (score: ${scores['es']}, includes special chars)`);
      return { lang: 'es', confidence: scores['es'] };
    }
    

    
    if (scores['en'] >= 2 && scores['en'] >= scores['it'] && scores['en'] >= scores['es']) {
      console.log(`   ‚úì Detected: ENGLISH (score: ${scores['en']})`);
      return { lang: 'en', confidence: scores['en'] };
    }
    
    if (maxScore < 2) {
      console.log('   Low confidence, defaulting to Italian');
      return { lang: 'it', confidence: maxScore };
    }
    
    console.log(`   ‚úì Detected: ${detectedLang.toUpperCase()} (score: ${maxScore})`);
    return { lang: detectedLang, confidence: maxScore };
  }
  
  // ========================================================================
  // SALUTO ADATTIVO
  // ========================================================================
  
  /**
   * Ottieni saluto e chiusura adattati a lingua, ora E giorni speciali
   * ‚úÖ RIPRISTINATO: Versione completa con supporto calendario liturgico
   */
  getAdaptiveGreeting(senderName, language = 'it') {
    const now = new Date();
    const hour = now.getHours();
    const day = now.getDay(); // 0 = Domenica
    
    let greeting, closing;
    
    // ‚úÖ Prima verifica saluto giorno speciale (nuovo)
    const specialGreeting = this._getSpecialDayGreeting(now, language);
    if (specialGreeting) {
      greeting = specialGreeting;
    } else {
      // Fallback a saluto standard basato sull'ora
      if (language === 'it') {
        if (day === 0) {
          greeting = 'Buona domenica.';
        } else if (hour >= 6 && hour < 13) {
          greeting = 'Buongiorno.';
        } else if (hour >= 13 && hour < 19) {
          greeting = 'Buon pomeriggio.';
        } else {
          greeting = 'Buonasera.';
        }
      } else if (language === 'en') {
        if (day === 0) {
          greeting = 'Happy Sunday,';
        } else if (hour >= 6 && hour < 12) {
          greeting = 'Good morning,';
        } else if (hour >= 12 && hour < 18) {
          greeting = 'Good afternoon,';
        } else {
          greeting = 'Good evening,';
        }
      } else if (language === 'es') {
        if (day === 0) {
          greeting = 'Feliz domingo,';
        } else if (hour >= 6 && hour < 13) {
          greeting = 'Buenos d√≠as,';
        } else {
          greeting = 'Buenas tardes,';
        }
      } else {
        greeting = `Gentile ${senderName},`;
      }
    }
    
    // Imposta chiusura in base alla lingua
    if (language === 'it') {
      closing = 'Cordiali saluti,';
    } else if (language === 'en') {
      closing = 'Kind regards,';
    } else if (language === 'es') {
      closing = 'Cordiales saludos,';
    } else {
      closing = 'Cordiali saluti,';
    }
    
    return { greeting, closing };
  }
  
  // ========================================================================
  // SALUTI GIORNI SPECIALI (RIPRISTINATO)
  // ========================================================================
  
  /**
   * Ottieni saluto speciale per feste liturgiche e festivit√†
   * ‚úÖ RIPRISTINATO: Supporto completo calendario liturgico
   */
  _getSpecialDayGreeting(dateObj, language = 'it') {
    const y = dateObj.getFullYear();
    const m = dateObj.getMonth() + 1;
    const d = dateObj.getDate();
    
    // ===== FESTIVIT√Ä FISSE =====
    
    // Capodanno
    if (m === 1 && d === 1) {
      if (language === 'en') return 'Happy New Year!';
      if (language === 'es') return '¬°Feliz A√±o Nuevo!';
      if (language === 'de') return 'Frohes neues Jahr!';
      return 'Buon Capodanno!';
    }
    
    // Epifania
    if (m === 1 && d === 6) {
      if (language === 'en') return 'Happy Epiphany!';
      if (language === 'es') return '¬°Feliz Epifan√≠a!';
      if (language === 'de') return 'Frohes Dreik√∂nigsfest!';
      return 'Buona Epifania!';
    }
    
    // Assunzione (15 Agosto)
    if (m === 8 && d === 15) {
      if (language === 'en') return 'Happy Assumption Day!';
      if (language === 'es') return '¬°Feliz d√≠a de la Asunci√≥n!';
      if (language === 'de') return 'Frohes Mari√§ Himmelfahrt!';
      return 'Buona festa!';
    }
    
    // Tutti i Santi (1 Novembre)
    if (m === 11 && d === 1) {
      if (language === 'en') return 'Happy All Saints Day!';
      if (language === 'es') return '¬°Feliz d√≠a de Todos los Santos!';
      if (language === 'de') return 'Frohes Allerheiligen!';
      return 'Buona festa di Ognissanti!';
    }
    
    // Immacolata Concezione (8 Dicembre)
    if (m === 12 && d === 8) {
      if (language === 'en') return 'Happy Feast of the Immaculate Conception!';
      if (language === 'es') return '¬°Feliz d√≠a de la Inmaculada!';
      if (language === 'de') return 'Frohes Fest der Unbefleckten Empf√§ngnis!';
      return 'Buona Immacolata!';
    }
    
    // Natale (25 Dicembre)
    if (m === 12 && d === 25) {
      if (language === 'en') return 'Merry Christmas!';
      if (language === 'es') return '¬°Feliz Navidad!';
      if (language === 'de') return 'Frohe Weihnachten!';
      return 'Buon Natale!';
    }
    
    // ===== FESTE MOBILI (basate sulla Pasqua) =====
    
    const easter = this._getWesternEasterDate(y);
    
    // Ottava di Pasqua (Domenica di Pasqua + 7 giorni)
    const pasquaStart = easter;
    const pasquaEnd = this._addDays(easter, 7);
    if (this._isBetweenInclusive(dateObj, pasquaStart, pasquaEnd)) {
      if (language === 'en') return 'Happy Easter!';
      if (language === 'es') return '¬°Feliz Pascua!';
      if (language === 'de') return 'Frohe Ostern!';
      return 'Buona Pasqua!';
    }
    
    // Pentecoste (Pasqua + 49 giorni)
    const pentecoste = this._addDays(easter, 49);
    if (this._isSameDate(dateObj, pentecoste)) {
      if (language === 'en') return 'Happy Pentecost!';
      if (language === 'es') return '¬°Feliz Pentecost√©s!';
      if (language === 'de') return 'Frohes Pfingsten!';
      return 'Buona Pentecoste!';
    }
    
    // Corpus Domini (Pasqua + 63 giorni in Italia)
    const corpusDominiIT = this._addDays(easter, 63);
    if (this._isSameDate(dateObj, corpusDominiIT)) {
      if (language === 'en') return 'Happy Corpus Christi!';
      if (language === 'es') return '¬°Feliz Corpus Christi!';
      if (language === 'de') return 'Frohes Fronleichnam!';
      return 'Buona festa!';
    }
    
    // Domenica della Sacra Famiglia (domenica tra Natale e Capodanno, o 30 Dic se nessuna domenica)
    const sacraFamiglia = this._getHolyFamilySunday(y);
    if (sacraFamiglia && this._isSameDate(dateObj, sacraFamiglia)) {
      if (language === 'en') return 'Happy Feast of the Holy Family!';
      if (language === 'es') return '¬°Feliz Fiesta de la Sagrada Familia!';
      if (language === 'de') return 'Frohes Fest der Heiligen Familie!';
      return 'Buona Festa della Sacra Famiglia.';
    }
    
    return null; // Nessun giorno speciale
  }
  
  // ========================================================================
  // UTILIT√Ä DATE PER CALENDARIO LITURGICO
  // ========================================================================
  
  /**
   * Calcola la data della Pasqua occidentale usando l'algoritmo Gregoriano anonimo
   */
  _getWesternEasterDate(year) {
    const a = year % 19;
    const b = Math.floor(year / 100);
    const c = year % 100;
    const d = Math.floor(b / 4);
    const e = b % 4;
    const f = Math.floor((b + 8) / 25);
    const g = Math.floor((b - f + 1) / 3);
    const h = (19 * a + b - d - g + 15) % 30;
    const i = Math.floor(c / 4);
    const k = c % 4;
    const l = (32 + 2 * e + 2 * i - h - k) % 7;
    const m = Math.floor((a + 11 * h + 22 * l) / 451);
    const month = Math.floor((h + l - 7 * m + 114) / 31);
    const day = ((h + l - 7 * m + 114) % 31) + 1;
    return new Date(year, month - 1, day);
  }
  
  /**
   * Aggiunge giorni a una data
   */
  _addDays(date, days) {
    const result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
  }
  
  /**
   * Verifica se due date sono lo stesso giorno
   */
  _isSameDate(date1, date2) {
    return date1.getFullYear() === date2.getFullYear() &&
           date1.getMonth() === date2.getMonth() &&
           date1.getDate() === date2.getDate();
  }
  
  /**
   * Verifica se una data √® compresa tra inizio e fine (inclusi)
   */
  _isBetweenInclusive(date, start, end) {
    const d = date.getTime();
    const s = start.getTime();
    const e = end.getTime();
    return d >= s && d <= e;
  }
  
  /**
   * Ottieni la data della Domenica della Sacra Famiglia
   * (Domenica tra 25 Dic e 1 Gen, o 30 Dic se nessuna domenica)
   */
  _getHolyFamilySunday(year) {
    // Controlla i giorni dal 26 al 31 Dicembre
    for (let day = 26; day <= 31; day++) {
      const date = new Date(year, 11, day); // Mese 11 = Dicembre
      if (date.getDay() === 0) { // Domenica
        return date;
      }
    }
    // Se nessuna domenica trovata, usa 30 Dicembre
    return new Date(year, 11, 30);
  }
  
  // ========================================================================
  // QUICK CHECK (Decisione risposta + Rilevamento lingua)
  // ========================================================================
  
  /**
   * Chiamata rapida Gemini per decidere se email richiede risposta E rilevare lingua
   * ‚úÖ AGGIORNATO: Migliorata gestione errori e fallback
   */
  shouldRespondToEmail(emailContent, emailSubject) {
    const prompt = `Analizza questa email.
Rispondi ESCLUSIVAMENTE con un oggetto JSON.

Email:
Oggetto: ${emailSubject}
Testo: ${emailContent.substring(0, 800)}

Compiti:
1. Decidi se richiede risposta (reply_needed).
2. Rileva la lingua dell'email (language) - usa codice ISO 639-1 (es: "it", "en", "es", "fr", "de", "pl", "tr", "pt", etc.).
3. Classifica la richiesta (category) in una di queste:
   - "TECHNICAL": orari, documenti, procedure, info pratiche
   - "PASTORAL": richieste di aiuto, sfogo, situazioni personali, lutto, richiesta colloqui personali
   - "DOCTRINAL": dubbi di fede, domande teologiche, "perch√© la chiesa..."
   - "MIXED": mix di tecnica e pastorale (es. cerco info ma sono arrabbiato/triste)
4. Estrai l'argomento principale (topic) es. "Battesimo", "Messa", "Orari", "Lutto".
5. Fornisci un breve ragionamento (reason).

Output JSON atteso:
{
  "reply_needed": boolean,
  "language": "string (codice ISO 639-1, es: it, en, es, fr, de, pl, tr...)",
  "category": "TECHNICAL" | "PASTORAL" | "DOCTRINAL" | "MIXED",
  "topic": "string",
  "confidence": number (0.0-1.0),
  "reason": "string"
}`;

    // ‚úÖ FIX: Usa rilevamento locale keyword come fallback solo per la lingua
    // NOTA: Alta confidenza salta SOLO ri-rilevamento lingua, NON la decisione shouldRespond
    // Gemini deve SEMPRE valutare se rispondere (filtra newsletter, ringraziamenti, ecc.)
    const detection = this.detectEmailLanguage(emailContent, emailSubject);
    const fallbackLang = detection.lang;

    const defaultResult = { shouldRespond: true, language: fallbackLang, reason: 'failsafe_local_detection' };
    
    try {
      console.log(`üîç Gemini quick check for: ${emailSubject.substring(0, 40)}...`);
      
      const result = this._withRetry(() => {
        const response = UrlFetchApp.fetch(`${this.baseUrl}?key=${this.apiKey}`, {
          method: 'POST',
          contentType: 'application/json',
          payload: JSON.stringify({
            contents: [{ parts: [{ text: prompt }] }],
            generationConfig: {
              temperature: 0,
              maxOutputTokens: 1024  // Aumentato per evitare troncamento
            }
          }),
          muteHttpExceptions: true
        });
        
        const responseCode = response.getResponseCode();
        if (responseCode === 429 || responseCode === 503) {
          throw new Error(`rate limit or service unavailable: ${responseCode}`);
        }
        if (responseCode !== 200) {
          throw new Error(`API error: ${responseCode} - ${response.getContentText()}`);
        }
        
        return JSON.parse(response.getContentText());
      }, 'Quick check');
      
      if (!result.candidates || !result.candidates[0]) {
        console.warn('‚ö†Ô∏è Quick check: No candidates, defaulting to fallback');
        return defaultResult;
      }
      
      // Verifica blocchi di sicurezza o altri problemi
      const candidate = result.candidates[0];
      if (candidate.finishReason && candidate.finishReason !== 'STOP') {
        console.warn(`‚ö†Ô∏è Quick check: Unusual finishReason: ${candidate.finishReason}`);
      }
      
      try {
        const textResponse = candidate.content.parts[0].text;
        console.log(`   Quick check response length: ${textResponse.length} chars`);
        
        try {
          const data = parseGeminiJsonLenient(textResponse);

          return {
            shouldRespond: data.reply_needed === true,
            language: (data.language || fallbackLang).toLowerCase(),
            reason: data.reason || 'quick_check',
            classification: {
              category: data.category || 'TECHNICAL',
              topic: data.topic || '',
              confidence: data.confidence || 0.8
            }
          };

        } catch (parseError) {
          console.warn('‚ö†Ô∏è Quick check parse failed, using local detection');
          console.warn(`   Parse error: ${parseError.message}`);
          console.warn(`   Response preview: ${textResponse.substring(0, 100)}...`);
          return defaultResult;
        }
        
      } catch (outerError) {
        console.error(`‚ùå Quick check outer error: ${outerError.message}`);
        return defaultResult;
      }
      
    } catch (error) {
      console.warn(`‚ö†Ô∏è Quick check failed: ${error.message}, using local detection`);
      return defaultResult;
    }
  }
  
  // ========================================================================
  // GENERAZIONE RISPOSTA PRINCIPALE (con retry)
  // ========================================================================
  
  /**
   * Genera risposta AI con retry
   */
  generateResponse(prompt) {
    return this._withRetry(() => {
      console.log(`ü§ñ Calling Gemini API (prompt size: ${prompt.length} chars)...`);
      
      const temperature = typeof CONFIG !== 'undefined' ? CONFIG.TEMPERATURE : 0.5;
      const maxTokens = typeof CONFIG !== 'undefined' ? CONFIG.MAX_OUTPUT_TOKENS : 4000;
      
      const response = UrlFetchApp.fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        contentType: 'application/json',
        payload: JSON.stringify({
          contents: [{ parts: [{ text: prompt }] }],
          generationConfig: {
            temperature: temperature,
            maxOutputTokens: maxTokens
          }
        }),
        muteHttpExceptions: true
      });
      
      const responseCode = response.getResponseCode();
      
      // Gestisci errori ritentabili
      if (responseCode === 429 || responseCode === 503) {
        throw new Error(`rate limit or service unavailable: ${responseCode}`);
      }
      
      if (responseCode !== 200) {
        console.error(`‚ùå Gemini API error: ${responseCode}`);
        console.error(`   Response: ${response.getContentText().substring(0, 500)}`);
        return null;
      }
      
      const result = JSON.parse(response.getContentText());
      
      if (!result.candidates || !result.candidates[0] || !result.candidates[0].content) {
        console.error('‚ùå Invalid Gemini response: no candidates or content');
        return null;
      }
      
      const generatedText = result.candidates[0].content.parts[0].text;
      
      if (!generatedText || generatedText.trim().length === 0) {
        console.error('‚ùå Gemini returned empty response');
        return null;
      }
      
      console.log(`‚úì Response generated (${generatedText.length} chars)`);
      return generatedText;
      
    }, 'Generate response');
  }
  
  // ========================================================================
  // METODI UTILIT√Ä
  // ========================================================================
  
  // NOTA: isOnlyAcknowledgement() rimossa - usare Classifier._isUltraSimpleAcknowledgment()
  // NOTA: extractMainReply() rimossa - usare GmailService.extractMainReply()
  
  /**
   * Testa connessione API Gemini
   */
  testConnection() {
    const results = {
      connectionOk: false,
      canGenerate: false,
      errors: []
    };
    
    try {
      const testPrompt = 'Rispondi con una sola parola: OK';
      
      const response = UrlFetchApp.fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        contentType: 'application/json',
        payload: JSON.stringify({
          contents: [{ parts: [{ text: testPrompt }] }],
          generationConfig: {
            temperature: 0.1,
            maxOutputTokens: 10
          }
        }),
        muteHttpExceptions: true
      });
      
      results.connectionOk = response.getResponseCode() === 200;
      
      if (results.connectionOk) {
        const result = JSON.parse(response.getContentText());
        if (result.candidates) {
          results.canGenerate = true;
        } else {
          results.errors.push('API returned no candidates');
        }
      } else {
        results.errors.push(`API returned status ${response.getResponseCode()}`);
      }
      
    } catch (error) {
      results.errors.push(`Connection error: ${error.message}`);
    }
    
    results.isHealthy = results.connectionOk && results.canGenerate;
    return results;
  }
}

// Funzione factory per compatibilit√†
function createGeminiService() {
  return new GeminiService();
}

// ====================================================================
// JSON PARSER TOLLERANTE PER GEMINI (Quick Check)
// ====================================================================

function parseGeminiJsonLenient(text) {
  if (!text) throw new Error('Empty response');

  // 1. Rimuovi blocchi codice markdown
  let cleaned = text
    .replace(/```json/gi, '')
    .replace(/```/g, '')
    .trim();

  // 2. Isola solo il contenuto tra { e }
  const match = cleaned.match(/\{[\s\S]*\}/);
  if (!match) {
    throw new Error('No JSON object found');
  }

  cleaned = match[0];

  // 3. Tentativo parsing diretto
  try {
    return JSON.parse(cleaned);
  } catch (e) {
    // Continua con normalizzazione
  }

  // 4. Normalizzazione JS-like ‚Üí JSON (solo chiavi non quotate)
  // NON modificare i valori per evitare corruzioni di stringhe
  const normalized = cleaned
    // Quota solo le chiavi non quotate (pattern sicuro)
    .replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":');

  return JSON.parse(normalized);
}

