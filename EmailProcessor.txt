// ====================================================================
// EMAIL PROCESSOR - Orchestratore Pipeline (Allineato a CF)
// ‚úÖ Clear pipeline: Filter ‚Üí Classify ‚Üí Generate ‚Üí Validate
// ‚úÖ Modular architecture with dependency injection
// ====================================================================

/**
 * EmailProcessor - Aligned with CF email_processor.py
 * 
 * PIPELINE:
 * 1. FILTER: Should we process this email?
 * 2. CLASSIFY: What type of request is it?
 * 3. GENERATE: Create AI response
 * 4. VALIDATE: Check response quality
 * 5. SEND: Reply to email
 */
class EmailProcessor {
  constructor(options = {}) {
    console.log('üì¨ Initializing EmailProcessor (CF-aligned)...');
    
    // Inject dependencies or create defaults
    this.geminiService = options.geminiService || new GeminiService();
    this.classifier = options.classifier || new EmailClassifier();
    this.requestClassifier = options.requestClassifier || new RequestTypeClassifier();
    this.validator = options.validator || new ResponseValidator();
    this.gmailService = options.gmailService || new GmailService();
    this.territoryValidator = options.territoryValidator || new TerritoryValidator();
    this.promptEngine = options.promptEngine || new PromptEngine();
    this.memoryService = options.memoryService || new MemoryService();
    
    // Configuration
    this.config = {
      validationEnabled: typeof CONFIG !== 'undefined' ? CONFIG.VALIDATION_ENABLED : true,
      dryRun: typeof CONFIG !== 'undefined' ? CONFIG.DRY_RUN : false,
      maxEmailsPerRun: typeof CONFIG !== 'undefined' ? CONFIG.MAX_EMAILS_PER_RUN : 10,
      labelName: typeof CONFIG !== 'undefined' ? CONFIG.LABEL_NAME : 'IA',
      errorLabelName: typeof CONFIG !== 'undefined' ? CONFIG.ERROR_LABEL_NAME : 'IA-Error',
      validationErrorLabel: typeof CONFIG !== 'undefined' ? CONFIG.VALIDATION_ERROR_LABEL : 'IA_VALIDATION_ERROR'
    };
    
    console.log('‚úì EmailProcessor initialized');
    console.log(`   Validation: ${this.config.validationEnabled ? 'ENABLED' : 'DISABLED'}`);
    console.log(`   Dry run: ${this.config.dryRun ? 'YES' : 'NO'}`);
  }
  
  /**
   * Process a single email thread
   * ‚úÖ ALIGNED: Same pipeline as CF process_thread
   */
  processThread(thread, knowledgeBase, doctrineBase = '') {
    const result = {
      status: 'unknown',
      validationFailed: false,
      dryRun: false,
      error: null
    };
    
    try {
      // Get last message in thread
      const messages = thread.getMessages();
      const lastMessage = messages[messages.length - 1];
      const messageDetails = this.gmailService.extractMessageDetails(lastMessage);
      
      console.log(`\nüìß Processing: ${messageDetails.subject.substring(0, 50)}...`);
      console.log(`   From: ${messageDetails.senderEmail}`);
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // STEP 0: ANTI-SELF-REPLY (mandatory first check)
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      const myEmail = Session.getActiveUser().getEmail();
      if (messageDetails.senderEmail.toLowerCase() === myEmail.toLowerCase()) {
        console.log('   ‚äò Skipped: self-sent message');
        this._markAsProcessed(thread);
        result.status = 'skipped';
        result.reason = 'self_sent';
        return result;
      }
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // STEP 0.5: ANTI-LOOP (thread too long = possible infinite loop)
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      const MAX_THREAD_LENGTH = 10;
      if (messages.length > MAX_THREAD_LENGTH) {
        console.log(`   ‚äò Skipped: thread too long (${messages.length} > ${MAX_THREAD_LENGTH})`);
        this._markAsProcessed(thread);
        result.status = 'skipped';
        result.reason = 'thread_too_long';
        return result;
      }
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // STEP 0.8: ANTI-NOREPLY SENDER (explicit check)
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      if (/no-reply|do-not-reply|noreply/i.test(messageDetails.senderEmail)) {
        console.log('   ‚äò Skipped: no-reply sender');
        this._markAsProcessed(thread);
        result.status = 'filtered';
        result.reason = 'no_reply_sender';
        return result;
      }
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // STEP 1: FILTER - Domain/keyword ignores
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      if (this._shouldIgnoreEmail(messageDetails)) {
        console.log('   ‚äò Filtered: domain/keyword ignore');
        this._markAsProcessed(thread);
        result.status = 'filtered';
        return result;
      }
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // STEP 2: CLASSIFY - Ultra-simple ack/greeting filter
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      const classification = this.classifier.classifyEmail(
        messageDetails.subject,
        messageDetails.body,
        messageDetails.subject.toLowerCase().startsWith('re:')
      );
      
      if (!classification.shouldReply) {
        console.log(`   ‚äò Filtered by classifier: ${classification.reason}`);
        this._markAsProcessed(thread);
        result.status = 'filtered';
        return result;
      }
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // STEP 3: QUICK CHECK - Gemini decides if response needed
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      const quickCheck = this.geminiService.shouldRespondToEmail(
        messageDetails.body,
        messageDetails.subject
      );
      
      if (!quickCheck.shouldRespond) {
        console.log(`   ‚äò Gemini quick check: no response needed (${quickCheck.reason})`);
        this._markAsProcessed(thread);
        result.status = 'filtered';
        return result;
      }
      
      const detectedLanguage = quickCheck.language;
      console.log(`   üåç Language: ${detectedLanguage.toUpperCase()}`);
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // STEP 4: REQUEST TYPE CLASSIFICATION - Technical/Pastoral/Mixed
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      const requestType = this.requestClassifier.classify(
        messageDetails.subject,
        messageDetails.body
      );
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // STEP 5: TERRITORY CHECK - If address found
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      const territoryResult = this.territoryValidator.analyzeEmailForAddress(
        messageDetails.body,
        messageDetails.subject
      );
      
      let enrichedKnowledgeBase = knowledgeBase;
      
      // 5.1: SPECIAL MASS RULE INJECTION (Prioritary)
      const specialMassRule = getSpecialMassTimeRule(new Date());
      if (specialMassRule) {
        console.log('   üö® Special Mass Rule Injected into Prompt');
        enrichedKnowledgeBase = specialMassRule + '\n\n' + enrichedKnowledgeBase;
      }

      if (territoryResult.addressFound) {
        const v = territoryResult.verification;
        const territoryContext = `
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üéØ VERIFICA TERRITORIO AUTOMATICA (INFORMAZIONE VERIFICATA)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Indirizzo: ${territoryResult.street} n. ${territoryResult.civic}

Risultato: ${v.inParish ? '‚úÖ RIENTRA' : '‚ùå NON RIENTRA'}

Dettaglio: ${v.reason}

‚ö†Ô∏è Usa ESATTAMENTE queste informazioni verificate programmaticamente.
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
`;
        enrichedKnowledgeBase = territoryContext + '\n\n' + knowledgeBase;
      }
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // STEP 6: BUILD CONVERSATION HISTORY
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      let conversationHistory = '';
      if (messages.length > 1) {
        conversationHistory = this.gmailService.buildConversationHistory(
          messages.slice(0, -1), // All except last
          10 // Max messages
        );
      }
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // STEP 6.5: GET MEMORY CONTEXT (avoid repetition)
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      const threadId = thread.getId();
      const memoryContext = this.memoryService.getMemory(threadId);
      
      if (Object.keys(memoryContext).length > 0) {
        console.log(`   üß† Memory found: lang=${memoryContext.language}, topics=${(memoryContext.providedInfo || []).length}`);
      }
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // STEP 6.6: COMPUTE SALUTATION MODE
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      const salutationMode = computeSalutationMode({
        isReply: messageDetails.subject.toLowerCase().startsWith('re:'),
        messageCount: memoryContext.messageCount || messages.length,
        memoryExists: Object.keys(memoryContext).length > 0,
        lastUpdated: memoryContext.lastUpdated || null,
        now: new Date()
      });
      console.log(`   üìù Salutation mode: ${salutationMode}`);
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // STEP 7: BUILD PROMPT
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      let { greeting, closing } = this.geminiService.getAdaptiveGreeting(
        messageDetails.senderName,
        detectedLanguage
      );
      
      // üî¥ OVERRIDE STRUTTURALE: nessun saluto rituale in conversazioni attive
      if (salutationMode === 'none_or_continuity') {
        greeting = '';
      } else if (salutationMode === 'soft') {
        // Soft mode: frase di riaggancio cortese dopo pausa
        greeting = '[Inizia con una breve frase di riaggancio cordiale, es: "Riprendiamo la nostra conversazione..." o "Grazie per essere tornato/a..."]';
      }
      
      // STEP 7: BUILD PROMPT CONTEXT
const promptContext = createPromptContext({
  email: {
    subject: messageDetails.subject,
    body: messageDetails.body,
    isReply: messageDetails.subject.toLowerCase().startsWith('re:'),
    detectedLanguage: detectedLanguage
  },

  classification: {
    category: classification.category,
    subIntents: classification.subIntents || {},
    confidence: classification.confidence || 0.8
  },

  requestType: requestType,

  memory: {
    exists: Object.keys(memoryContext).length > 0,
    providedInfoCount: (memoryContext.providedInfo || []).length
  },

  conversation: {
    messageCount: memoryContext.messageCount || messages.length
  },

  territory: {
    addressFound: territoryResult.addressFound
  },

  knowledgeBase: {
    length: enrichedKnowledgeBase.length,
    containsDates: /\d{4}/.test(enrichedKnowledgeBase)
  },

  temporal: {
    mentionsDates: /\b(gennaio|febbraio|marzo|aprile|maggio|giugno|luglio|agosto|settembre|ottobre|novembre|dicembre|\d{1,2}\/\d{1,2})\b/i.test(messageDetails.body),
    mentionsTimes: /\d{1,2}[:.]\d{2}/.test(messageDetails.body)
  }
});
console.log('üß† PromptContext:', JSON.stringify(promptContext.meta));

// NEW CALL
const prompt = this.promptEngine.buildPrompt({
  ...promptContext,
  emailContent: messageDetails.body,
  emailSubject: messageDetails.subject,
  knowledgeBase: enrichedKnowledgeBase,
  senderName: messageDetails.senderName,
  senderEmail: messageDetails.senderEmail,
  conversationHistory: conversationHistory,
  memoryContext: memoryContext,
  detectedLanguage: detectedLanguage,
  currentSeason: this._getCurrentSeason(),
  currentDate: new Date().toISOString().split('T')[0],
  salutation: greeting,
  closing: closing,
  category: classification.category,
  subIntents: classification.subIntents || {}
});
      
      // Add request type hint
      const typeHint = this.requestClassifier.getRequestTypeHint(requestType.type);
      const fullPrompt = typeHint + '\n\n' + prompt;
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // STEP 8: GENERATE RESPONSE
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      const response = this.geminiService.generateResponse(fullPrompt);
      
      if (!response) {
        console.error('   ‚ùå Failed to generate response');
        this._addErrorLabel(thread);
        result.status = 'error';
        result.error = 'Generation failed';
        return result;
      }
      
      // Check for NO_REPLY marker
      if (response.trim() === 'NO_REPLY' || response.includes('NO_REPLY')) {
        console.log('   ‚äò AI returned NO_REPLY');
        this._markAsProcessed(thread);
        result.status = 'filtered';
        return result;
      }
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // STEP 9: VALIDATE RESPONSE
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      if (this.config.validationEnabled) {
        const validation = this.validator.validateResponse(
          response,
          detectedLanguage,
          enrichedKnowledgeBase,
          messageDetails.body,
          messageDetails.subject
        );
        
        if (!validation.isValid) {
          console.warn(`   ‚ùå Validation FAILED (score: ${validation.score.toFixed(2)})`);
          this._addValidationErrorLabel(thread);
          result.status = 'validation_failed';
          result.validationFailed = true;
          return result;
        }
        
        console.log(`   ‚úì Validation PASSED (score: ${validation.score.toFixed(2)})`);
      }
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // STEP 10: SEND REPLY
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      if (this.config.dryRun) {
        console.log('   üî¥ DRY RUN - Not sending reply');
        console.log(`   üìù Would send: ${response.substring(0, 100)}...`);
        result.dryRun = true;
      } else {
        this.gmailService.sendHtmlReply(thread, response, messageDetails);
      }
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // STEP 11: UPDATE MEMORY (for next interaction)
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      this.memoryService.updateMemory(threadId, {
        language: detectedLanguage,
        category: classification.category || requestType.type
      });
      
      // Detect provided topics from response
      const providedTopics = this._detectProvidedTopics(response);
      if (providedTopics.length > 0) {
        this.memoryService.addProvidedInfoTopics(threadId, providedTopics);
      }
      
      this._markAsProcessed(thread);
      result.status = 'replied';
      return result;
      
    } catch (error) {
      console.error(`   ‚ùå Error processing thread: ${error.message}`);
      this._addErrorLabel(thread);
      result.status = 'error';
      result.error = error.message;
      return result;
    }
  }
  
  /**
   * Process all unread emails
   * ‚úÖ ALIGNED: Same as CF process_unread_emails
   */
  processUnreadEmails(knowledgeBase, doctrineBase = '') {
    console.log('\n' + '='.repeat(70));
    console.log('üì¨ Starting email processing...');
    console.log('='.repeat(70));
    
    if (this.config.dryRun) {
      console.warn('üî¥ DRY_RUN MODE ACTIVE - Emails will NOT be sent!');
    }
    
    // Search for unread threads
    const threads = GmailApp.search(
      `is:unread -label:${this.config.labelName}`,
      0,
      this.config.maxEmailsPerRun
    );
    
    if (threads.length === 0) {
      console.log('Nessuna email da processare.');
      return { total: 0, replied: 0, filtered: 0, errors: 0 };
    }
    
    console.log(`üì¨ Trovate ${threads.length} email da elaborare`);
    
    // Stats
    const stats = {
      total: 0,
      replied: 0,
      filtered: 0,
      validationFailed: 0,
      errors: 0,
      dryRun: 0,
      skipped: 0
    };
    
    // Process each thread
    threads.forEach((thread, index) => {
      console.log(`\n--- Thread ${index + 1}/${threads.length} ---`);
      
      const result = this.processThread(thread, knowledgeBase, doctrineBase);
      stats.total++;
      
      if (result.validationFailed) {
        stats.validationFailed++;
      } else if (result.status === 'replied') {
        stats.replied++;
        if (result.dryRun) stats.dryRun++;
      } else if (result.status === 'skipped') {
        stats.skipped++;
      } else if (result.status === 'filtered') {
        stats.filtered++;
      } else if (result.status === 'error') {
        stats.errors++;
      }
    });
    
    // Print summary
    console.log('\n' + '='.repeat(70));
    console.log('üìä RIEPILOGO ELABORAZIONE');
    console.log('='.repeat(70));
    console.log(`   Totale processate: ${stats.total}`);
    console.log(`   ‚úì Risposte inviate: ${stats.replied}`);
    if (stats.dryRun > 0) console.warn(`   üî¥ DRY RUN: ${stats.dryRun}`);
    if (stats.skipped > 0) console.log(`   ‚äò Skipped (self-sent): ${stats.skipped}`);
    console.log(`   ‚äò Filtrate: ${stats.filtered}`);
    if (stats.validationFailed > 0) console.warn(`   ‚ùå Validazione fallita: ${stats.validationFailed}`);
    if (stats.errors > 0) console.error(`   ‚ùå Errori: ${stats.errors}`);
    console.log('='.repeat(70));
    
    return stats;
  }
  
  // ========================================================================
  // HELPER METHODS
  // ========================================================================
  
  _shouldIgnoreEmail(messageDetails) {
    // Get ignore lists from CONFIG or GLOBAL_CACHE with safe fallbacks
    let ignoreDomains = [];
    let ignoreKeywords = [];
    
    if (typeof GLOBAL_CACHE !== 'undefined' && GLOBAL_CACHE.ignoreDomains) {
      ignoreDomains = GLOBAL_CACHE.ignoreDomains;
    } else if (typeof CONFIG !== 'undefined' && CONFIG.IGNORE_DOMAINS) {
      ignoreDomains = CONFIG.IGNORE_DOMAINS;
    }
    
    if (typeof GLOBAL_CACHE !== 'undefined' && GLOBAL_CACHE.ignoreKeywords) {
      ignoreKeywords = GLOBAL_CACHE.ignoreKeywords;
    } else if (typeof CONFIG !== 'undefined' && CONFIG.IGNORE_KEYWORDS) {
      ignoreKeywords = CONFIG.IGNORE_KEYWORDS;
    }
    
    const email = messageDetails.senderEmail.toLowerCase();
    const subject = messageDetails.subject.toLowerCase();
    const body = messageDetails.body.toLowerCase();
    
    // Check domains
    for (const domain of ignoreDomains) {
      if (email.includes(domain.toLowerCase())) {
        console.log(`   Domain ignored: ${domain}`);
        return true;
      }
    }
    
    // Check keywords
    for (const keyword of ignoreKeywords) {
      if (subject.includes(keyword.toLowerCase()) || body.includes(keyword.toLowerCase())) {
        console.log(`   Keyword ignored: ${keyword}`);
        return true;
      }
    }
    
    return false;
  }
  
  _getCurrentSeason() {
    const month = new Date().getMonth() + 1; // 1-12
    // Estivo: June-September, otherwise Invernale
    return (month >= 6 && month <= 9) ? 'estivo' : 'invernale';
  }
  
  _markAsProcessed(thread) {
    this.gmailService.addLabelToThread(thread, this.config.labelName);
  }
  
  _addErrorLabel(thread) {
    this.gmailService.addLabelToThread(thread, this.config.errorLabelName);
  }
  
  _addValidationErrorLabel(thread) {
    this.gmailService.addLabelToThread(thread, this.config.validationErrorLabel);
  }
  
  /**
   * Detect topics provided in the response (for memory anti-repetition)
   */
  _detectProvidedTopics(response) {
    const topics = [];
    const lower = response.toLowerCase();
    
    // Topic patterns
    const patterns = {
      'orari_messe': /messe?\b.*\d{1,2}[:.]\d{2}|orari\w*\s+messe/i,
      'contatti': /telefono|email|@|segreteria/i,
      'battesimo_info': /battesimo.*documento|documento.*battesimo/i,
      'comunione_info': /comunione.*catechismo|catechismo.*comunione/i,
      'cresima_info': /cresima.*percorso|percorso.*cresima/i,
      'matrimonio_info': /matrimonio.*corso|corso.*matrimonio/i,
      'territorio': /rientra|non rientra|parrocchia.*competenza/i,
      'indirizzo': /(?:via|viale|corso|piazza|largo|circonvallazione)\s+[a-zA-Z√†√®√©√¨√≤√π√Ä√à√â√å√í√ô']+(?:\s+[a-zA-Z√†√®√©√¨√≤√π√Ä√à√â√å√í√ô']+)*\s*,?\s*\d+/i
    };
    
    for (const [topic, pattern] of Object.entries(patterns)) {
      if (pattern.test(lower)) {
        topics.push(topic);
      }
    }
    
    return topics;
  }
}

// ====================================================================
// SALUTATION MODE CALCULATOR
// Determines greeting mode based on conversation state
// ====================================================================

/**
 * Compute salutation mode based on structural signals
 * @param {Object} params - Input parameters
 * @param {boolean} params.isReply - Is this a reply?
 * @param {number} params.messageCount - Number of messages in thread
 * @param {boolean} params.memoryExists - Does memory exist for this thread?
 * @param {string|null} params.lastUpdated - ISO timestamp of last memory update
 * @param {Date} params.now - Current date
 * @returns {'full'|'soft'|'none_or_continuity'}
 */
function computeSalutationMode({ isReply, messageCount, memoryExists, lastUpdated, now = new Date() }) {
  // 1Ô∏è‚É£ Primo messaggio assoluto
  if (!isReply && !memoryExists && messageCount <= 1) {
    return 'full';
  }

  // 2Ô∏è‚É£ Conversazione attiva (reply o thread gi√† avviato)
  if (isReply || messageCount > 1 || memoryExists) {
    // Se non sappiamo quando √® stata l'ultima interazione ‚Üí continuit√†
    if (!lastUpdated) {
      return 'none_or_continuity';
    }

    const hoursSinceLast = (now.getTime() - new Date(lastUpdated).getTime()) / (1000 * 60 * 60);

    // 2aÔ∏è‚É£ Follow-up ravvicinato (entro 48h)
    if (hoursSinceLast <= 48) {
      return 'none_or_continuity';
    }

    // 2bÔ∏è‚É£ Conversazione ripresa dopo pausa
    return 'soft';
  }

  // Fallback di sicurezza
  return 'full';
}

// Factory function
function createEmailProcessor(options) {
  return new EmailProcessor(options);
}

// ====================================================================
// MAIN ENTRY POINT - For script trigger
// ====================================================================

function processUnreadEmailsMain() {
  try {
    // Check suspension time
    if (typeof isInSuspensionTime === 'function' && isInSuspensionTime()) {
      console.log('Servizio sospeso per orario di lavoro.');
      return;
    }
    
    // Load resources
    if (typeof loadResources === 'function') {
      loadResources();
    }
    
    // Get knowledge base
    const knowledgeBase = typeof GLOBAL_CACHE !== 'undefined' ? 
                          GLOBAL_CACHE.knowledgeBase || '' : '';
    const doctrineBase = typeof GLOBAL_CACHE !== 'undefined' ? 
                         GLOBAL_CACHE.doctrineBase || '' : '';
    
    // Create processor and run
    const processor = new EmailProcessor();
    processor.processUnreadEmails(knowledgeBase, doctrineBase);
    
  } catch (error) {
    console.error(`‚ùå Errore nel processo principale: ${error.message}`);
  }
}
