// ====================================================================
// MEMORY SERVICE - Memoria conversazionale per GAS
// ‚úÖ Usa Google Sheet come storage
// ‚úÖ Stessa struttura dati di versione Python
// ====================================================================

/**
 * MemoryService - Versione GAS usando Google Sheets
 * 
 * STORAGE: Google Sheet "ConversationMemory" con colonne:
 * A: threadId
 * B: language
 * C: category
 * D: tone
 * E: providedInfo (JSON array)
 * F: lastUpdated (timestamp)
 * G: messageCount
 * 
 * CONFIGURATION:
 * - Aggiungi MEMORY_SHEET_NAME in CONFIG (default: 'ConversationMemory')
 * - Il foglio sar√† creato automaticamente se non esiste
 */
class MemoryService {
  constructor() {
    console.log('üß† Inizializzazione MemoryService (basato su Sheet)...');
    
    // Configurazione
    this.spreadsheetId = typeof CONFIG !== 'undefined' ? CONFIG.SPREADSHEET_ID : null;
    this.sheetName = typeof CONFIG !== 'undefined' ? 
                     (CONFIG.MEMORY_SHEET_NAME || 'ConversationMemory') : 
                     'ConversationMemory';
    
    // Cache per performance (evita lookup ripetuti)
    this._cache = {};
    this._cacheExpiry = 5 * 60 * 1000; // 5 minuti
    
    // Inizializza foglio
    this._sheet = null;
    this._initialized = false;
    
    if (this.spreadsheetId) {
      this._initializeSheet();
    } else {
      console.warn('‚ö†Ô∏è SPREADSHEET_ID not configured, MemoryService disabled');
    }
  }
  
  /**
   * Inizializza o crea il foglio memoria
   */
  _initializeSheet() {
    try {
      const spreadsheet = SpreadsheetApp.openById(this.spreadsheetId);
      this._sheet = spreadsheet.getSheetByName(this.sheetName);
      
      if (!this._sheet) {
        // Crea nuovo foglio con intestazioni
        this._sheet = spreadsheet.insertSheet(this.sheetName);
        this._sheet.getRange('A1:G1').setValues([[
          'threadId', 'language', 'category', 'tone', 
          'providedInfo', 'lastUpdated', 'messageCount'
        ]]);
        this._sheet.getRange('A1:G1').setFontWeight('bold');
        this._sheet.setFrozenRows(1);
        console.log(`‚úì Created new sheet: ${this.sheetName}`);
      }
      
      this._initialized = true;
      console.log(`‚úì MemoryService initialized (Sheet: ${this.sheetName})`);
      
    } catch (error) {
      console.error(`‚ùå Failed to initialize MemoryService: ${error.message}`);
      this._initialized = false;
    }
  }
  
  /**
   * Ottiene memoria per un thread
   */
  getMemory(threadId) {
    if (!this._initialized || !threadId) {
      return {};
    }
    
    // Verifica prima la cache
    const cacheKey = `memory_${threadId}`;
    const cached = this._getFromCache(cacheKey);
    if (cached) {
      console.log(`üß† Memory hit (cached) for thread ${threadId}`);
      return cached;
    }
    
    try {
      // Trova riga per threadId
      const row = this._findRowByThreadId(threadId);
      
      if (row) {
        const data = this._rowToObject(row);
        console.log(`üß† Memory hit for thread ${threadId} (Lang: ${data.language})`);
        
        // Memorizza in cache
        this._setCache(cacheKey, data);
        return data;
      } else {
        console.log(`üß† Memory miss for thread ${threadId} (New conversation)`);
        return {};
      }
      
    } catch (error) {
      console.error(`‚ùå Error retrieving memory: ${error.message}`);
      return {};
    }
  }
  
  /**
   * Aggiorna memoria per un thread (merge con esistente)
   */
  updateMemory(threadId, newData) {
    if (!this._initialized || !threadId) {
      return;
    }
    
    // ‚úÖ FIX: Aggiunge lock per prevenire race condition
    const lock = LockService.getScriptLock();
    try {
      lock.waitLock(5000);
      
      const existingRow = this._findRowByThreadId(threadId);
      const now = new Date().toISOString();
      
      if (existingRow) {
        // Unisci con dati esistenti
        const existingData = this._rowToObject(existingRow.values);
        const mergedData = Object.assign({}, existingData, newData);
        mergedData.lastUpdated = now;
        mergedData.messageCount = (existingData.messageCount || 0) + 1;
        
        // Aggiorna riga
        this._updateRow(existingRow.rowIndex, mergedData);
        console.log(`üß† Memory updated for thread ${threadId}`);
      } else {
        // Crea nuova riga
        newData.threadId = threadId;
        newData.lastUpdated = now;
        newData.messageCount = 1;
        
        this._appendRow(newData);
        console.log(`üß† Memory created for thread ${threadId}`);
      }
      
      // Invalida cache
      this._invalidateCache(`memory_${threadId}`);
      
    } catch (error) {
      console.error(`‚ùå Error updating memory: ${error.message}`);
    } finally {
      lock.releaseLock();
    }
  }
  
  /**
   * Aggiorna memoria E topic in un'unica operazione atomica
   * ‚úÖ Previene inconsistenze: tutto o niente in un singolo lock
   * 
   * @param {string} threadId - ID del thread
   * @param {Object} newData - Dati da aggiornare (language, category, tone, etc.)
   * @param {string[]} providedTopics - Topic da aggiungere (opzionale)
   * @returns {boolean} - true se l'operazione √® riuscita
   */
  updateMemoryAtomic(threadId, newData, providedTopics = null) {
    if (!this._initialized || !threadId) {
      return false;
    }
    
    const lock = LockService.getScriptLock();
    try {
      lock.waitLock(5000);
      
      const existingRow = this._findRowByThreadId(threadId);
      const now = new Date().toISOString();
      
      if (existingRow) {
        // Unisci con dati esistenti
        const existingData = this._rowToObject(existingRow.values);
        const mergedData = Object.assign({}, existingData, newData);
        mergedData.lastUpdated = now;
        mergedData.messageCount = (existingData.messageCount || 0) + 1;
        
        // ‚úÖ Unisci topic nello stesso lock (operazione atomica)
        if (providedTopics && providedTopics.length > 0) {
          const existingTopics = existingData.providedInfo || [];
          mergedData.providedInfo = [...new Set([...existingTopics, ...providedTopics])];
          console.log(`üß† Memory: Atomically added topics ${JSON.stringify(providedTopics)}`);
        }
        
        // Aggiorna riga
        this._updateRow(existingRow.rowIndex, mergedData);
        console.log(`üß† Memory atomically updated for thread ${threadId}`);
      } else {
        // Crea nuova riga con eventualmente i topic
        newData.threadId = threadId;
        newData.lastUpdated = now;
        newData.messageCount = 1;
        
        if (providedTopics && providedTopics.length > 0) {
          newData.providedInfo = providedTopics;
        }
        
        this._appendRow(newData);
        console.log(`üß† Memory atomically created for thread ${threadId}`);
      }
      
      // Invalida cache
      this._invalidateCache(`memory_${threadId}`);
      return true;
      
    } catch (error) {
      console.error(`‚ùå Error in atomic memory update: ${error.message}`);
      return false;
    } finally {
      lock.releaseLock();
    }
  }
  
  /**
   * Aggiunge topic alla lista info fornite
   * ‚úÖ FIX: Non incrementa messageCount (evita doppio incremento)
   */
   addProvidedInfoTopics(threadId, topics) {
     if (!this._initialized || !threadId || !topics || topics.length === 0) {
       return;
     }
 
     try {
      // Acquisisce lock script per evitare race condition
      const lock = LockService.getScriptLock();
      lock.waitLock(5000); // wait up to 5 seconds
      try {
        const existingRow = this._findRowByThreadId(threadId);
        if (existingRow) {
          // Unisci topic senza incrementare messageCount
          const existingData = this._rowToObject(existingRow.values);
          const existingTopics = existingData.providedInfo || [];
          const mergedTopics = [...new Set([...existingTopics, ...topics])];
          
          // Aggiorna solo providedInfo, preserva messageCount
          existingData.providedInfo = mergedTopics;
          existingData.lastUpdated = new Date().toISOString();
          // ‚úÖ NON incrementare messageCount qui
          
          this._updateRow(existingRow.rowIndex, existingData);
          this._invalidateCache(`memory_${threadId}`);
          console.log(`üß† Memory: Added provided topics ${JSON.stringify(topics)}`);
        }
      } finally {
        lock.releaseLock();
      }
    } catch (error) {
      console.error(`‚ùå Error adding provided info: ${error.message}`);
    }
   }
  
  /**
   * Imposta lingua per un thread
   */
  setLanguage(threadId, language) {
    this.updateMemory(threadId, { language: language });
  }
  
  /**
   * Imposta categoria per un thread
   */
  setCategory(threadId, category) {
    this.updateMemory(threadId, { category: category });
  }
  
  // ========================================================================
  // METODI HELPER PRIVATI
  // ========================================================================
  
  /**
   * Trova riga per threadId
   * Ritorna { rowIndex, values } o null
   */
  _findRowByThreadId(threadId) {
    const data = this._sheet.getDataRange().getValues();
    
    for (let i = 1; i < data.length; i++) { // Salta intestazione
      if (data[i][0] === threadId) {
        return {
          rowIndex: i + 1, // 1-indexed per Sheets
          values: data[i]
        };
      }
    }
    
    return null;
  }
  
  /**
   * Converte array riga in oggetto
   */
  _rowToObject(row) {
    // Gestisce sia array che oggetto con .values
    const values = Array.isArray(row) ? row : row.values || row;
    
    let providedInfo = [];
    try {
      if (values[4]) {
        providedInfo = JSON.parse(values[4]);
      }
    } catch (e) {
      providedInfo = values[4] ? [values[4]] : [];
    }
    
    return {
      threadId: values[0],
      language: values[1] || 'it',
      category: values[2] || null,
      tone: values[3] || 'standard',
      providedInfo: providedInfo,
      lastUpdated: values[5] || null,
      messageCount: parseInt(values[6]) || 0
    };
  }
  
  /**
   * Aggiorna riga esistente
   */
  _updateRow(rowIndex, data) {
    const providedInfoJson = JSON.stringify(data.providedInfo || []);
    
    this._sheet.getRange(rowIndex, 1, 1, 7).setValues([[
      data.threadId,
      data.language || 'it',
      data.category || '',
      data.tone || 'standard',
      providedInfoJson,
      data.lastUpdated,
      data.messageCount || 1
    ]]);
  }
  
  /**
   * Aggiunge nuova riga
   */
  _appendRow(data) {
    const providedInfoJson = JSON.stringify(data.providedInfo || []);
    
    this._sheet.appendRow([
      data.threadId,
      data.language || 'it',
      data.category || '',
      data.tone || 'standard',
      providedInfoJson,
      data.lastUpdated,
      data.messageCount || 1
    ]);
  }
  
  // ========================================================================
  // METODI CACHE
  // ========================================================================
  
  _getFromCache(key) {
    const cached = this._cache[key];
    if (cached && (Date.now() - cached.timestamp) < this._cacheExpiry) {
      return cached.data;
    }
    return null;
  }
  
  _setCache(key, data) {
    this._cache[key] = {
      data: data,
      timestamp: Date.now()
    };
  }
  
  _invalidateCache(key) {
    delete this._cache[key];
  }
  
  /**
   * Svuota tutta la cache
   */
  clearCache() {
    this._cache = {};
    console.log('üóëÔ∏è Memory cache cleared');
  }
  
  // ========================================================================
  // METODI UTILIT√Ä
  // ========================================================================
  
  /**
   * Pulisce voci vecchie (pi√π vecchie di N giorni)
   */
  cleanOldEntries(daysOld = 30) {
    if (!this._initialized) return 0;
    
    try {
      const data = this._sheet.getDataRange().getValues();
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - daysOld);
      
      let deletedCount = 0;
      
      // Vai all'indietro per evitare problemi di shifting indici
      for (let i = data.length - 1; i >= 1; i--) {
        const lastUpdated = new Date(data[i][5]);
        if (lastUpdated < cutoffDate) {
          this._sheet.deleteRow(i + 1);
          deletedCount++;
        }
      }
      
      console.log(`üßπ Cleaned ${deletedCount} old memory entries`);
      return deletedCount;
      
    } catch (error) {
      console.error(`‚ùå Error cleaning old entries: ${error.message}`);
      return 0;
    }
  }
  
  /**
   * Ottieni statistiche sull'uso della memoria
   */
  getStats() {
    if (!this._initialized) {
      return { initialized: false };
    }
    
    const data = this._sheet.getDataRange().getValues();
    return {
      initialized: true,
      sheetName: this.sheetName,
      totalEntries: data.length - 1, // Escludi intestazione
      cacheSize: Object.keys(this._cache).length
    };
  }
  
  /**
   * Verifica se il servizio √® sano
   */
  isHealthy() {
    return this._initialized;
  }
}

// Funzione factory
function createMemoryService() {
  return new MemoryService();
}

// ====================================================================
// FUNZIONE TRIGGER PULIZIA
// Esegui periodicamente per pulire le voci di memoria vecchie
// ====================================================================

function cleanupOldMemory() {
  const memoryService = new MemoryService();
  const deleted = memoryService.cleanOldEntries(30); // 30 giorni
  console.log(`Pulizia memoria completata: ${deleted} voci rimosse`);
}

// ====================================================================
// SETUP INIZIALE - ISTRUZIONI PER CLEANUP AUTOMATICO SETTIMANALE
// ====================================================================
//
// Per attivare il cleanup automatico della memoria conversazionale,
// eseguire UNA SOLA VOLTA la funzione `setupWeeklyCleanupTrigger()`.
//
// === ISTRUZIONI PASSO-PASSO ===
//
// 1. Aprire il progetto Google Apps Script (script.google.com)
// 2. Selezionare questo file (MemoryService.txt/gs)
// 3. Nel menu a tendina delle funzioni (in alto), selezionare:
//    `setupWeeklyCleanupTrigger`
// 4. Cliccare il pulsante ‚ñ∂Ô∏è "Esegui"
// 5. Se richiesto, autorizzare le permission per i trigger
// 6. Verificare nel log: "‚úì Weekly cleanup trigger created"
//
// === VERIFICA TRIGGER ATTIVO ===
//
// Per verificare che il trigger sia stato creato correttamente:
// 1. Cliccare sull'icona ‚è∞ "Trigger" nella barra laterale sinistra
// 2. Deve apparire un trigger con:
//    - Funzione: cleanupOldMemory
//    - Tipo: Time-driven (basato sul tempo)
//    - Frequenza: Weekly on Sunday, 3am‚Äì4am
//
// === COMPORTAMENTO ===
//
// - La funzione `cleanupOldMemory()` verr√† eseguita ogni domenica alle 3:00
// - Rimuove le conversazioni pi√π vecchie di 30 giorni
// - I log sono visibili in: Esecuzioni > Visualizza esecuzioni
//
// === NOTE ===
//
// - NON eseguire `setupWeeklyCleanupTrigger()` pi√π volte: rimuove
//   automaticamente trigger duplicati prima di crearne uno nuovo
// - Per disattivare: eliminare manualmente il trigger dalla sezione Trigger
// - Per modificare la frequenza: modificare i parametri in questa funzione
//
// ====================================================================

/**
 * Configura trigger settimanale per pulizia automatica memoria
 * ‚ö†Ô∏è ESEGUI UNA SOLA VOLTA manualmente per attivare il cleanup automatico
 * 
 * Il trigger eseguir√† cleanupOldMemory() ogni domenica alle 3:00
 * 
 * @example
 * // Esecuzione manuale da GAS Editor:
 * // 1. Selezionare setupWeeklyCleanupTrigger dal menu funzioni
 * // 2. Cliccare Esegui (‚ñ∂Ô∏è)
 * // 3. Autorizzare se richiesto
 */
function setupWeeklyCleanupTrigger() {
  // Rimuovi trigger esistenti per evitare duplicati
  const triggers = ScriptApp.getProjectTriggers();
  let removed = 0;
  for (const trigger of triggers) {
    if (trigger.getHandlerFunction() === 'cleanupOldMemory') {
      ScriptApp.deleteTrigger(trigger);
      removed++;
    }
  }
  if (removed > 0) {
    console.log(`üóëÔ∏è Removed ${removed} existing cleanup trigger(s)`);
  }
  
  // Crea trigger settimanale (domenica alle 3:00)
  ScriptApp.newTrigger('cleanupOldMemory')
    .timeBased()
    .onWeekDay(ScriptApp.WeekDay.SUNDAY)
    .atHour(3)
    .create();
    
  console.log('‚úì Weekly cleanup trigger created (Sunday 3:00 AM)');
}
